/*
 * Copyright (c) 2013-2015 TRUSTONIC LIMITED
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the TRUSTONIC LIMITED nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mc.proto

#ifndef PROTOBUF_mc_2eproto__INCLUDED
#define PROTOBUF_mc_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace trustonic {
namespace tee_proxy {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mc_2eproto();
void protobuf_AssignDesc_mc_2eproto();
void protobuf_ShutdownFile_mc_2eproto();

class OpenSessionRequest;
class OpenSessionResponse;
class OpenTrustletRequest;
class OpenTrustletResponse;
class CloseSessionRequest;
class CloseSessionResponse;
class NotifyRequest;
class NotifyRequest_Buffers;
class NotifyResponse;
class WaitNotificationRequest;
class WaitNotificationResponse;
class WaitNotificationResponse_Buffers;
class MapRequest;
class MapRequest_Buffers;
class MapResponse;
class MapResponse_Buffers;
class UnmapRequest;
class UnmapRequest_Buffers;
class UnmapResponse;
class GetErrorRequest;
class GetErrorResponse;
class GetVersionRequest;
class GetVersionResponse;
class GpRequestCancellationRequest;
class GpRequestCancellationResponse;

enum LoginType {
  TEEC_LOGIN_PUBLIC = 0,
  TEEC_LOGIN_USER = 1,
  TEEC_LOGIN_GROUP = 2,
  TEEC_LOGIN_APPLICATION = 4,
  TEEC_LOGIN_USER_APPLICATION = 5,
  TEEC_LOGIN_GROUP_APPLICATION = 6
};
bool LoginType_IsValid(int value);
const LoginType LoginType_MIN = TEEC_LOGIN_PUBLIC;
const LoginType LoginType_MAX = TEEC_LOGIN_GROUP_APPLICATION;
const int LoginType_ARRAYSIZE = LoginType_MAX + 1;

// ===================================================================

class OpenSessionRequest : public ::google::protobuf::MessageLite {
 public:
  OpenSessionRequest();
  virtual ~OpenSessionRequest();

  OpenSessionRequest(const OpenSessionRequest& from);

  inline OpenSessionRequest& operator=(const OpenSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const OpenSessionRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OpenSessionRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OpenSessionRequest* other);

  // implements Message ----------------------------------------------

  OpenSessionRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OpenSessionRequest& from);
  void MergeFrom(const OpenSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes uuid = 1;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 1;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // required bool is_gp_uuid = 2;
  inline bool has_is_gp_uuid() const;
  inline void clear_is_gp_uuid();
  static const int kIsGpUuidFieldNumber = 2;
  inline bool is_gp_uuid() const;
  inline void set_is_gp_uuid(bool value);

  // optional bytes tci = 3;
  inline bool has_tci() const;
  inline void clear_tci();
  static const int kTciFieldNumber = 3;
  inline const ::std::string& tci() const;
  inline void set_tci(const ::std::string& value);
  inline void set_tci(const char* value);
  inline void set_tci(const void* value, size_t size);
  inline ::std::string* mutable_tci();
  inline ::std::string* release_tci();
  inline void set_allocated_tci(::std::string* tci);

  // required .com.trustonic.tee_proxy.LoginType login_type = 4;
  inline bool has_login_type() const;
  inline void clear_login_type();
  static const int kLoginTypeFieldNumber = 4;
  inline ::com::trustonic::tee_proxy::LoginType login_type() const;
  inline void set_login_type(::com::trustonic::tee_proxy::LoginType value);

  // required bytes login_data = 5;
  inline bool has_login_data() const;
  inline void clear_login_data();
  static const int kLoginDataFieldNumber = 5;
  inline const ::std::string& login_data() const;
  inline void set_login_data(const ::std::string& value);
  inline void set_login_data(const char* value);
  inline void set_login_data(const void* value, size_t size);
  inline ::std::string* mutable_login_data();
  inline ::std::string* release_login_data();
  inline void set_allocated_login_data(::std::string* login_data);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.OpenSessionRequest)
 private:
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_is_gp_uuid();
  inline void clear_has_is_gp_uuid();
  inline void set_has_tci();
  inline void clear_has_tci();
  inline void set_has_login_type();
  inline void clear_has_login_type();
  inline void set_has_login_data();
  inline void clear_has_login_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* uuid_;
  ::std::string* tci_;
  bool is_gp_uuid_;
  int login_type_;
  ::std::string* login_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static OpenSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class OpenSessionResponse : public ::google::protobuf::MessageLite {
 public:
  OpenSessionResponse();
  virtual ~OpenSessionResponse();

  OpenSessionResponse(const OpenSessionResponse& from);

  inline OpenSessionResponse& operator=(const OpenSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const OpenSessionResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OpenSessionResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OpenSessionResponse* other);

  // implements Message ----------------------------------------------

  OpenSessionResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OpenSessionResponse& from);
  void MergeFrom(const OpenSessionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.OpenSessionResponse)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static OpenSessionResponse* default_instance_;
};
// -------------------------------------------------------------------

class OpenTrustletRequest : public ::google::protobuf::MessageLite {
 public:
  OpenTrustletRequest();
  virtual ~OpenTrustletRequest();

  OpenTrustletRequest(const OpenTrustletRequest& from);

  inline OpenTrustletRequest& operator=(const OpenTrustletRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const OpenTrustletRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OpenTrustletRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OpenTrustletRequest* other);

  // implements Message ----------------------------------------------

  OpenTrustletRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OpenTrustletRequest& from);
  void MergeFrom(const OpenTrustletRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 spid = 1;
  inline bool has_spid() const;
  inline void clear_spid();
  static const int kSpidFieldNumber = 1;
  inline ::google::protobuf::uint32 spid() const;
  inline void set_spid(::google::protobuf::uint32 value);

  // required bytes trustapp = 2;
  inline bool has_trustapp() const;
  inline void clear_trustapp();
  static const int kTrustappFieldNumber = 2;
  inline const ::std::string& trustapp() const;
  inline void set_trustapp(const ::std::string& value);
  inline void set_trustapp(const char* value);
  inline void set_trustapp(const void* value, size_t size);
  inline ::std::string* mutable_trustapp();
  inline ::std::string* release_trustapp();
  inline void set_allocated_trustapp(::std::string* trustapp);

  // optional bytes tci = 3;
  inline bool has_tci() const;
  inline void clear_tci();
  static const int kTciFieldNumber = 3;
  inline const ::std::string& tci() const;
  inline void set_tci(const ::std::string& value);
  inline void set_tci(const char* value);
  inline void set_tci(const void* value, size_t size);
  inline ::std::string* mutable_tci();
  inline ::std::string* release_tci();
  inline void set_allocated_tci(::std::string* tci);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.OpenTrustletRequest)
 private:
  inline void set_has_spid();
  inline void clear_has_spid();
  inline void set_has_trustapp();
  inline void clear_has_trustapp();
  inline void set_has_tci();
  inline void clear_has_tci();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* trustapp_;
  ::std::string* tci_;
  ::google::protobuf::uint32 spid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static OpenTrustletRequest* default_instance_;
};
// -------------------------------------------------------------------

class OpenTrustletResponse : public ::google::protobuf::MessageLite {
 public:
  OpenTrustletResponse();
  virtual ~OpenTrustletResponse();

  OpenTrustletResponse(const OpenTrustletResponse& from);

  inline OpenTrustletResponse& operator=(const OpenTrustletResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const OpenTrustletResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const OpenTrustletResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(OpenTrustletResponse* other);

  // implements Message ----------------------------------------------

  OpenTrustletResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const OpenTrustletResponse& from);
  void MergeFrom(const OpenTrustletResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.OpenTrustletResponse)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static OpenTrustletResponse* default_instance_;
};
// -------------------------------------------------------------------

class CloseSessionRequest : public ::google::protobuf::MessageLite {
 public:
  CloseSessionRequest();
  virtual ~CloseSessionRequest();

  CloseSessionRequest(const CloseSessionRequest& from);

  inline CloseSessionRequest& operator=(const CloseSessionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CloseSessionRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CloseSessionRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CloseSessionRequest* other);

  // implements Message ----------------------------------------------

  CloseSessionRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CloseSessionRequest& from);
  void MergeFrom(const CloseSessionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.CloseSessionRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static CloseSessionRequest* default_instance_;
};
// -------------------------------------------------------------------

class CloseSessionResponse : public ::google::protobuf::MessageLite {
 public:
  CloseSessionResponse();
  virtual ~CloseSessionResponse();

  CloseSessionResponse(const CloseSessionResponse& from);

  inline CloseSessionResponse& operator=(const CloseSessionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CloseSessionResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CloseSessionResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CloseSessionResponse* other);

  // implements Message ----------------------------------------------

  CloseSessionResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CloseSessionResponse& from);
  void MergeFrom(const CloseSessionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.CloseSessionResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static CloseSessionResponse* default_instance_;
};
// -------------------------------------------------------------------

class NotifyRequest_Buffers : public ::google::protobuf::MessageLite {
 public:
  NotifyRequest_Buffers();
  virtual ~NotifyRequest_Buffers();

  NotifyRequest_Buffers(const NotifyRequest_Buffers& from);

  inline NotifyRequest_Buffers& operator=(const NotifyRequest_Buffers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NotifyRequest_Buffers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyRequest_Buffers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyRequest_Buffers* other);

  // implements Message ----------------------------------------------

  NotifyRequest_Buffers* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyRequest_Buffers& from);
  void MergeFrom(const NotifyRequest_Buffers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 sva = 1;
  inline bool has_sva() const;
  inline void clear_sva();
  static const int kSvaFieldNumber = 1;
  inline ::google::protobuf::uint64 sva() const;
  inline void set_sva(::google::protobuf::uint64 value);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.NotifyRequest.Buffers)
 private:
  inline void set_has_sva();
  inline void clear_has_sva();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 sva_;
  ::std::string* data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static NotifyRequest_Buffers* default_instance_;
};
// -------------------------------------------------------------------

class NotifyRequest : public ::google::protobuf::MessageLite {
 public:
  NotifyRequest();
  virtual ~NotifyRequest();

  NotifyRequest(const NotifyRequest& from);

  inline NotifyRequest& operator=(const NotifyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NotifyRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyRequest* other);

  // implements Message ----------------------------------------------

  NotifyRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyRequest& from);
  void MergeFrom(const NotifyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef NotifyRequest_Buffers Buffers;

  // accessors -------------------------------------------------------

  // required uint32 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::uint32 sid() const;
  inline void set_sid(::google::protobuf::uint32 value);

  // optional bytes tci = 2;
  inline bool has_tci() const;
  inline void clear_tci();
  static const int kTciFieldNumber = 2;
  inline const ::std::string& tci() const;
  inline void set_tci(const ::std::string& value);
  inline void set_tci(const char* value);
  inline void set_tci(const void* value, size_t size);
  inline ::std::string* mutable_tci();
  inline ::std::string* release_tci();
  inline void set_allocated_tci(::std::string* tci);

  // repeated .com.trustonic.tee_proxy.NotifyRequest.Buffers buffers = 3;
  inline int buffers_size() const;
  inline void clear_buffers();
  static const int kBuffersFieldNumber = 3;
  inline const ::com::trustonic::tee_proxy::NotifyRequest_Buffers& buffers(int index) const;
  inline ::com::trustonic::tee_proxy::NotifyRequest_Buffers* mutable_buffers(int index);
  inline ::com::trustonic::tee_proxy::NotifyRequest_Buffers* add_buffers();
  inline const ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::NotifyRequest_Buffers >&
      buffers() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::NotifyRequest_Buffers >*
      mutable_buffers();

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.NotifyRequest)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_tci();
  inline void clear_has_tci();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tci_;
  ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::NotifyRequest_Buffers > buffers_;
  ::google::protobuf::uint32 sid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static NotifyRequest* default_instance_;
};
// -------------------------------------------------------------------

class NotifyResponse : public ::google::protobuf::MessageLite {
 public:
  NotifyResponse();
  virtual ~NotifyResponse();

  NotifyResponse(const NotifyResponse& from);

  inline NotifyResponse& operator=(const NotifyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NotifyResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NotifyResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NotifyResponse* other);

  // implements Message ----------------------------------------------

  NotifyResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NotifyResponse& from);
  void MergeFrom(const NotifyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.NotifyResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static NotifyResponse* default_instance_;
};
// -------------------------------------------------------------------

class WaitNotificationRequest : public ::google::protobuf::MessageLite {
 public:
  WaitNotificationRequest();
  virtual ~WaitNotificationRequest();

  WaitNotificationRequest(const WaitNotificationRequest& from);

  inline WaitNotificationRequest& operator=(const WaitNotificationRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const WaitNotificationRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WaitNotificationRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WaitNotificationRequest* other);

  // implements Message ----------------------------------------------

  WaitNotificationRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WaitNotificationRequest& from);
  void MergeFrom(const WaitNotificationRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::uint32 sid() const;
  inline void set_sid(::google::protobuf::uint32 value);

  // required sint32 timeout = 2;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  inline ::google::protobuf::int32 timeout() const;
  inline void set_timeout(::google::protobuf::int32 value);

  // required bool partial = 3;
  inline bool has_partial() const;
  inline void clear_partial();
  static const int kPartialFieldNumber = 3;
  inline bool partial() const;
  inline void set_partial(bool value);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.WaitNotificationRequest)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_partial();
  inline void clear_has_partial();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 sid_;
  ::google::protobuf::int32 timeout_;
  bool partial_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static WaitNotificationRequest* default_instance_;
};
// -------------------------------------------------------------------

class WaitNotificationResponse_Buffers : public ::google::protobuf::MessageLite {
 public:
  WaitNotificationResponse_Buffers();
  virtual ~WaitNotificationResponse_Buffers();

  WaitNotificationResponse_Buffers(const WaitNotificationResponse_Buffers& from);

  inline WaitNotificationResponse_Buffers& operator=(const WaitNotificationResponse_Buffers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const WaitNotificationResponse_Buffers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WaitNotificationResponse_Buffers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WaitNotificationResponse_Buffers* other);

  // implements Message ----------------------------------------------

  WaitNotificationResponse_Buffers* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WaitNotificationResponse_Buffers& from);
  void MergeFrom(const WaitNotificationResponse_Buffers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 sva = 1;
  inline bool has_sva() const;
  inline void clear_sva();
  static const int kSvaFieldNumber = 1;
  inline ::google::protobuf::uint64 sva() const;
  inline void set_sva(::google::protobuf::uint64 value);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers)
 private:
  inline void set_has_sva();
  inline void clear_has_sva();
  inline void set_has_data();
  inline void clear_has_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 sva_;
  ::std::string* data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static WaitNotificationResponse_Buffers* default_instance_;
};
// -------------------------------------------------------------------

class WaitNotificationResponse : public ::google::protobuf::MessageLite {
 public:
  WaitNotificationResponse();
  virtual ~WaitNotificationResponse();

  WaitNotificationResponse(const WaitNotificationResponse& from);

  inline WaitNotificationResponse& operator=(const WaitNotificationResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const WaitNotificationResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WaitNotificationResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WaitNotificationResponse* other);

  // implements Message ----------------------------------------------

  WaitNotificationResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WaitNotificationResponse& from);
  void MergeFrom(const WaitNotificationResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef WaitNotificationResponse_Buffers Buffers;

  // accessors -------------------------------------------------------

  // optional bytes tci = 1;
  inline bool has_tci() const;
  inline void clear_tci();
  static const int kTciFieldNumber = 1;
  inline const ::std::string& tci() const;
  inline void set_tci(const ::std::string& value);
  inline void set_tci(const char* value);
  inline void set_tci(const void* value, size_t size);
  inline ::std::string* mutable_tci();
  inline ::std::string* release_tci();
  inline void set_allocated_tci(::std::string* tci);

  // repeated .com.trustonic.tee_proxy.WaitNotificationResponse.Buffers buffers = 2;
  inline int buffers_size() const;
  inline void clear_buffers();
  static const int kBuffersFieldNumber = 2;
  inline const ::com::trustonic::tee_proxy::WaitNotificationResponse_Buffers& buffers(int index) const;
  inline ::com::trustonic::tee_proxy::WaitNotificationResponse_Buffers* mutable_buffers(int index);
  inline ::com::trustonic::tee_proxy::WaitNotificationResponse_Buffers* add_buffers();
  inline const ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::WaitNotificationResponse_Buffers >&
      buffers() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::WaitNotificationResponse_Buffers >*
      mutable_buffers();

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.WaitNotificationResponse)
 private:
  inline void set_has_tci();
  inline void clear_has_tci();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tci_;
  ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::WaitNotificationResponse_Buffers > buffers_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static WaitNotificationResponse* default_instance_;
};
// -------------------------------------------------------------------

class MapRequest_Buffers : public ::google::protobuf::MessageLite {
 public:
  MapRequest_Buffers();
  virtual ~MapRequest_Buffers();

  MapRequest_Buffers(const MapRequest_Buffers& from);

  inline MapRequest_Buffers& operator=(const MapRequest_Buffers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MapRequest_Buffers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapRequest_Buffers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapRequest_Buffers* other);

  // implements Message ----------------------------------------------

  MapRequest_Buffers* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapRequest_Buffers& from);
  void MergeFrom(const MapRequest_Buffers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 len = 1;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 1;
  inline ::google::protobuf::uint32 len() const;
  inline void set_len(::google::protobuf::uint32 value);

  // required uint32 flags = 2;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 2;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.MapRequest.Buffers)
 private:
  inline void set_has_len();
  inline void clear_has_len();
  inline void set_has_flags();
  inline void clear_has_flags();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 len_;
  ::google::protobuf::uint32 flags_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static MapRequest_Buffers* default_instance_;
};
// -------------------------------------------------------------------

class MapRequest : public ::google::protobuf::MessageLite {
 public:
  MapRequest();
  virtual ~MapRequest();

  MapRequest(const MapRequest& from);

  inline MapRequest& operator=(const MapRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MapRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapRequest* other);

  // implements Message ----------------------------------------------

  MapRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapRequest& from);
  void MergeFrom(const MapRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef MapRequest_Buffers Buffers;

  // accessors -------------------------------------------------------

  // required uint32 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::uint32 sid() const;
  inline void set_sid(::google::protobuf::uint32 value);

  // repeated .com.trustonic.tee_proxy.MapRequest.Buffers buffers = 2;
  inline int buffers_size() const;
  inline void clear_buffers();
  static const int kBuffersFieldNumber = 2;
  inline const ::com::trustonic::tee_proxy::MapRequest_Buffers& buffers(int index) const;
  inline ::com::trustonic::tee_proxy::MapRequest_Buffers* mutable_buffers(int index);
  inline ::com::trustonic::tee_proxy::MapRequest_Buffers* add_buffers();
  inline const ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::MapRequest_Buffers >&
      buffers() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::MapRequest_Buffers >*
      mutable_buffers();

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.MapRequest)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::MapRequest_Buffers > buffers_;
  ::google::protobuf::uint32 sid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static MapRequest* default_instance_;
};
// -------------------------------------------------------------------

class MapResponse_Buffers : public ::google::protobuf::MessageLite {
 public:
  MapResponse_Buffers();
  virtual ~MapResponse_Buffers();

  MapResponse_Buffers(const MapResponse_Buffers& from);

  inline MapResponse_Buffers& operator=(const MapResponse_Buffers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MapResponse_Buffers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapResponse_Buffers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapResponse_Buffers* other);

  // implements Message ----------------------------------------------

  MapResponse_Buffers* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapResponse_Buffers& from);
  void MergeFrom(const MapResponse_Buffers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 sva = 1;
  inline bool has_sva() const;
  inline void clear_sva();
  static const int kSvaFieldNumber = 1;
  inline ::google::protobuf::uint64 sva() const;
  inline void set_sva(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.MapResponse.Buffers)
 private:
  inline void set_has_sva();
  inline void clear_has_sva();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 sva_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static MapResponse_Buffers* default_instance_;
};
// -------------------------------------------------------------------

class MapResponse : public ::google::protobuf::MessageLite {
 public:
  MapResponse();
  virtual ~MapResponse();

  MapResponse(const MapResponse& from);

  inline MapResponse& operator=(const MapResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MapResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapResponse* other);

  // implements Message ----------------------------------------------

  MapResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapResponse& from);
  void MergeFrom(const MapResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef MapResponse_Buffers Buffers;

  // accessors -------------------------------------------------------

  // repeated .com.trustonic.tee_proxy.MapResponse.Buffers buffers = 1;
  inline int buffers_size() const;
  inline void clear_buffers();
  static const int kBuffersFieldNumber = 1;
  inline const ::com::trustonic::tee_proxy::MapResponse_Buffers& buffers(int index) const;
  inline ::com::trustonic::tee_proxy::MapResponse_Buffers* mutable_buffers(int index);
  inline ::com::trustonic::tee_proxy::MapResponse_Buffers* add_buffers();
  inline const ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::MapResponse_Buffers >&
      buffers() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::MapResponse_Buffers >*
      mutable_buffers();

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.MapResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::MapResponse_Buffers > buffers_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static MapResponse* default_instance_;
};
// -------------------------------------------------------------------

class UnmapRequest_Buffers : public ::google::protobuf::MessageLite {
 public:
  UnmapRequest_Buffers();
  virtual ~UnmapRequest_Buffers();

  UnmapRequest_Buffers(const UnmapRequest_Buffers& from);

  inline UnmapRequest_Buffers& operator=(const UnmapRequest_Buffers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UnmapRequest_Buffers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnmapRequest_Buffers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnmapRequest_Buffers* other);

  // implements Message ----------------------------------------------

  UnmapRequest_Buffers* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnmapRequest_Buffers& from);
  void MergeFrom(const UnmapRequest_Buffers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 sva = 1;
  inline bool has_sva() const;
  inline void clear_sva();
  static const int kSvaFieldNumber = 1;
  inline ::google::protobuf::uint64 sva() const;
  inline void set_sva(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.UnmapRequest.Buffers)
 private:
  inline void set_has_sva();
  inline void clear_has_sva();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 sva_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static UnmapRequest_Buffers* default_instance_;
};
// -------------------------------------------------------------------

class UnmapRequest : public ::google::protobuf::MessageLite {
 public:
  UnmapRequest();
  virtual ~UnmapRequest();

  UnmapRequest(const UnmapRequest& from);

  inline UnmapRequest& operator=(const UnmapRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UnmapRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnmapRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnmapRequest* other);

  // implements Message ----------------------------------------------

  UnmapRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnmapRequest& from);
  void MergeFrom(const UnmapRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef UnmapRequest_Buffers Buffers;

  // accessors -------------------------------------------------------

  // required uint32 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::uint32 sid() const;
  inline void set_sid(::google::protobuf::uint32 value);

  // repeated .com.trustonic.tee_proxy.UnmapRequest.Buffers buffers = 2;
  inline int buffers_size() const;
  inline void clear_buffers();
  static const int kBuffersFieldNumber = 2;
  inline const ::com::trustonic::tee_proxy::UnmapRequest_Buffers& buffers(int index) const;
  inline ::com::trustonic::tee_proxy::UnmapRequest_Buffers* mutable_buffers(int index);
  inline ::com::trustonic::tee_proxy::UnmapRequest_Buffers* add_buffers();
  inline const ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::UnmapRequest_Buffers >&
      buffers() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::UnmapRequest_Buffers >*
      mutable_buffers();

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.UnmapRequest)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::UnmapRequest_Buffers > buffers_;
  ::google::protobuf::uint32 sid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static UnmapRequest* default_instance_;
};
// -------------------------------------------------------------------

class UnmapResponse : public ::google::protobuf::MessageLite {
 public:
  UnmapResponse();
  virtual ~UnmapResponse();

  UnmapResponse(const UnmapResponse& from);

  inline UnmapResponse& operator=(const UnmapResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UnmapResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnmapResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnmapResponse* other);

  // implements Message ----------------------------------------------

  UnmapResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnmapResponse& from);
  void MergeFrom(const UnmapResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.UnmapResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static UnmapResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetErrorRequest : public ::google::protobuf::MessageLite {
 public:
  GetErrorRequest();
  virtual ~GetErrorRequest();

  GetErrorRequest(const GetErrorRequest& from);

  inline GetErrorRequest& operator=(const GetErrorRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetErrorRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetErrorRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetErrorRequest* other);

  // implements Message ----------------------------------------------

  GetErrorRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetErrorRequest& from);
  void MergeFrom(const GetErrorRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::uint32 sid() const;
  inline void set_sid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.GetErrorRequest)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 sid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static GetErrorRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetErrorResponse : public ::google::protobuf::MessageLite {
 public:
  GetErrorResponse();
  virtual ~GetErrorResponse();

  GetErrorResponse(const GetErrorResponse& from);

  inline GetErrorResponse& operator=(const GetErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetErrorResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetErrorResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetErrorResponse* other);

  // implements Message ----------------------------------------------

  GetErrorResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetErrorResponse& from);
  void MergeFrom(const GetErrorResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint32 exit_code = 1;
  inline bool has_exit_code() const;
  inline void clear_exit_code();
  static const int kExitCodeFieldNumber = 1;
  inline ::google::protobuf::int32 exit_code() const;
  inline void set_exit_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.GetErrorResponse)
 private:
  inline void set_has_exit_code();
  inline void clear_has_exit_code();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 exit_code_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static GetErrorResponse* default_instance_;
};
// -------------------------------------------------------------------

class GetVersionRequest : public ::google::protobuf::MessageLite {
 public:
  GetVersionRequest();
  virtual ~GetVersionRequest();

  GetVersionRequest(const GetVersionRequest& from);

  inline GetVersionRequest& operator=(const GetVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetVersionRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetVersionRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetVersionRequest* other);

  // implements Message ----------------------------------------------

  GetVersionRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetVersionRequest& from);
  void MergeFrom(const GetVersionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.GetVersionRequest)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static GetVersionRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetVersionResponse : public ::google::protobuf::MessageLite {
 public:
  GetVersionResponse();
  virtual ~GetVersionResponse();

  GetVersionResponse(const GetVersionResponse& from);

  inline GetVersionResponse& operator=(const GetVersionResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetVersionResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetVersionResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetVersionResponse* other);

  // implements Message ----------------------------------------------

  GetVersionResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetVersionResponse& from);
  void MergeFrom(const GetVersionResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string product_id = 1;
  inline bool has_product_id() const;
  inline void clear_product_id();
  static const int kProductIdFieldNumber = 1;
  inline const ::std::string& product_id() const;
  inline void set_product_id(const ::std::string& value);
  inline void set_product_id(const char* value);
  inline void set_product_id(const char* value, size_t size);
  inline ::std::string* mutable_product_id();
  inline ::std::string* release_product_id();
  inline void set_allocated_product_id(::std::string* product_id);

  // required uint32 mci = 2;
  inline bool has_mci() const;
  inline void clear_mci();
  static const int kMciFieldNumber = 2;
  inline ::google::protobuf::uint32 mci() const;
  inline void set_mci(::google::protobuf::uint32 value);

  // required uint32 so = 3;
  inline bool has_so() const;
  inline void clear_so();
  static const int kSoFieldNumber = 3;
  inline ::google::protobuf::uint32 so() const;
  inline void set_so(::google::protobuf::uint32 value);

  // required uint32 mclf = 4;
  inline bool has_mclf() const;
  inline void clear_mclf();
  static const int kMclfFieldNumber = 4;
  inline ::google::protobuf::uint32 mclf() const;
  inline void set_mclf(::google::protobuf::uint32 value);

  // required uint32 container = 5;
  inline bool has_container() const;
  inline void clear_container();
  static const int kContainerFieldNumber = 5;
  inline ::google::protobuf::uint32 container() const;
  inline void set_container(::google::protobuf::uint32 value);

  // required uint32 mc_config = 6;
  inline bool has_mc_config() const;
  inline void clear_mc_config();
  static const int kMcConfigFieldNumber = 6;
  inline ::google::protobuf::uint32 mc_config() const;
  inline void set_mc_config(::google::protobuf::uint32 value);

  // required uint32 tl_api = 7;
  inline bool has_tl_api() const;
  inline void clear_tl_api();
  static const int kTlApiFieldNumber = 7;
  inline ::google::protobuf::uint32 tl_api() const;
  inline void set_tl_api(::google::protobuf::uint32 value);

  // required uint32 dr_api = 8;
  inline bool has_dr_api() const;
  inline void clear_dr_api();
  static const int kDrApiFieldNumber = 8;
  inline ::google::protobuf::uint32 dr_api() const;
  inline void set_dr_api(::google::protobuf::uint32 value);

  // required uint32 nwd = 9;
  inline bool has_nwd() const;
  inline void clear_nwd();
  static const int kNwdFieldNumber = 9;
  inline ::google::protobuf::uint32 nwd() const;
  inline void set_nwd(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.GetVersionResponse)
 private:
  inline void set_has_product_id();
  inline void clear_has_product_id();
  inline void set_has_mci();
  inline void clear_has_mci();
  inline void set_has_so();
  inline void clear_has_so();
  inline void set_has_mclf();
  inline void clear_has_mclf();
  inline void set_has_container();
  inline void clear_has_container();
  inline void set_has_mc_config();
  inline void clear_has_mc_config();
  inline void set_has_tl_api();
  inline void clear_has_tl_api();
  inline void set_has_dr_api();
  inline void clear_has_dr_api();
  inline void set_has_nwd();
  inline void clear_has_nwd();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* product_id_;
  ::google::protobuf::uint32 mci_;
  ::google::protobuf::uint32 so_;
  ::google::protobuf::uint32 mclf_;
  ::google::protobuf::uint32 container_;
  ::google::protobuf::uint32 mc_config_;
  ::google::protobuf::uint32 tl_api_;
  ::google::protobuf::uint32 dr_api_;
  ::google::protobuf::uint32 nwd_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static GetVersionResponse* default_instance_;
};
// -------------------------------------------------------------------

class GpRequestCancellationRequest : public ::google::protobuf::MessageLite {
 public:
  GpRequestCancellationRequest();
  virtual ~GpRequestCancellationRequest();

  GpRequestCancellationRequest(const GpRequestCancellationRequest& from);

  inline GpRequestCancellationRequest& operator=(const GpRequestCancellationRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GpRequestCancellationRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpRequestCancellationRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpRequestCancellationRequest* other);

  // implements Message ----------------------------------------------

  GpRequestCancellationRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpRequestCancellationRequest& from);
  void MergeFrom(const GpRequestCancellationRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::uint32 sid() const;
  inline void set_sid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.GpRequestCancellationRequest)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 sid_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static GpRequestCancellationRequest* default_instance_;
};
// -------------------------------------------------------------------

class GpRequestCancellationResponse : public ::google::protobuf::MessageLite {
 public:
  GpRequestCancellationResponse();
  virtual ~GpRequestCancellationResponse();

  GpRequestCancellationResponse(const GpRequestCancellationResponse& from);

  inline GpRequestCancellationResponse& operator=(const GpRequestCancellationResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GpRequestCancellationResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GpRequestCancellationResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GpRequestCancellationResponse* other);

  // implements Message ----------------------------------------------

  GpRequestCancellationResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GpRequestCancellationResponse& from);
  void MergeFrom(const GpRequestCancellationResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:com.trustonic.tee_proxy.GpRequestCancellationResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_mc_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_mc_2eproto();
  #endif
  friend void protobuf_AssignDesc_mc_2eproto();
  friend void protobuf_ShutdownFile_mc_2eproto();

  void InitAsDefaultInstance();
  static GpRequestCancellationResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// OpenSessionRequest

// required bytes uuid = 1;
inline bool OpenSessionRequest::has_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenSessionRequest::set_has_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenSessionRequest::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenSessionRequest::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& OpenSessionRequest::uuid() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.OpenSessionRequest.uuid)
  return *uuid_;
}
inline void OpenSessionRequest::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.OpenSessionRequest.uuid)
}
inline void OpenSessionRequest::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.trustonic.tee_proxy.OpenSessionRequest.uuid)
}
inline void OpenSessionRequest::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.trustonic.tee_proxy.OpenSessionRequest.uuid)
}
inline ::std::string* OpenSessionRequest::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    uuid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.OpenSessionRequest.uuid)
  return uuid_;
}
inline ::std::string* OpenSessionRequest::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OpenSessionRequest::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.trustonic.tee_proxy.OpenSessionRequest.uuid)
}

// required bool is_gp_uuid = 2;
inline bool OpenSessionRequest::has_is_gp_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenSessionRequest::set_has_is_gp_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenSessionRequest::clear_has_is_gp_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenSessionRequest::clear_is_gp_uuid() {
  is_gp_uuid_ = false;
  clear_has_is_gp_uuid();
}
inline bool OpenSessionRequest::is_gp_uuid() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.OpenSessionRequest.is_gp_uuid)
  return is_gp_uuid_;
}
inline void OpenSessionRequest::set_is_gp_uuid(bool value) {
  set_has_is_gp_uuid();
  is_gp_uuid_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.OpenSessionRequest.is_gp_uuid)
}

// optional bytes tci = 3;
inline bool OpenSessionRequest::has_tci() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpenSessionRequest::set_has_tci() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpenSessionRequest::clear_has_tci() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpenSessionRequest::clear_tci() {
  if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_->clear();
  }
  clear_has_tci();
}
inline const ::std::string& OpenSessionRequest::tci() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.OpenSessionRequest.tci)
  return *tci_;
}
inline void OpenSessionRequest::set_tci(const ::std::string& value) {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  tci_->assign(value);
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.OpenSessionRequest.tci)
}
inline void OpenSessionRequest::set_tci(const char* value) {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  tci_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.trustonic.tee_proxy.OpenSessionRequest.tci)
}
inline void OpenSessionRequest::set_tci(const void* value, size_t size) {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  tci_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.trustonic.tee_proxy.OpenSessionRequest.tci)
}
inline ::std::string* OpenSessionRequest::mutable_tci() {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.OpenSessionRequest.tci)
  return tci_;
}
inline ::std::string* OpenSessionRequest::release_tci() {
  clear_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tci_;
    tci_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OpenSessionRequest::set_allocated_tci(::std::string* tci) {
  if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tci_;
  }
  if (tci) {
    set_has_tci();
    tci_ = tci;
  } else {
    clear_has_tci();
    tci_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.trustonic.tee_proxy.OpenSessionRequest.tci)
}

// required .com.trustonic.tee_proxy.LoginType login_type = 4;
inline bool OpenSessionRequest::has_login_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OpenSessionRequest::set_has_login_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OpenSessionRequest::clear_has_login_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OpenSessionRequest::clear_login_type() {
  login_type_ = 0;
  clear_has_login_type();
}
inline ::com::trustonic::tee_proxy::LoginType OpenSessionRequest::login_type() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.OpenSessionRequest.login_type)
  return static_cast< ::com::trustonic::tee_proxy::LoginType >(login_type_);
}
inline void OpenSessionRequest::set_login_type(::com::trustonic::tee_proxy::LoginType value) {
  assert(::com::trustonic::tee_proxy::LoginType_IsValid(value));
  set_has_login_type();
  login_type_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.OpenSessionRequest.login_type)
}

// required bytes login_data = 5;
inline bool OpenSessionRequest::has_login_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OpenSessionRequest::set_has_login_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OpenSessionRequest::clear_has_login_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OpenSessionRequest::clear_login_data() {
  if (login_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_data_->clear();
  }
  clear_has_login_data();
}
inline const ::std::string& OpenSessionRequest::login_data() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.OpenSessionRequest.login_data)
  return *login_data_;
}
inline void OpenSessionRequest::set_login_data(const ::std::string& value) {
  set_has_login_data();
  if (login_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_data_ = new ::std::string;
  }
  login_data_->assign(value);
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.OpenSessionRequest.login_data)
}
inline void OpenSessionRequest::set_login_data(const char* value) {
  set_has_login_data();
  if (login_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_data_ = new ::std::string;
  }
  login_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.trustonic.tee_proxy.OpenSessionRequest.login_data)
}
inline void OpenSessionRequest::set_login_data(const void* value, size_t size) {
  set_has_login_data();
  if (login_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_data_ = new ::std::string;
  }
  login_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.trustonic.tee_proxy.OpenSessionRequest.login_data)
}
inline ::std::string* OpenSessionRequest::mutable_login_data() {
  set_has_login_data();
  if (login_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    login_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.OpenSessionRequest.login_data)
  return login_data_;
}
inline ::std::string* OpenSessionRequest::release_login_data() {
  clear_has_login_data();
  if (login_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = login_data_;
    login_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OpenSessionRequest::set_allocated_login_data(::std::string* login_data) {
  if (login_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete login_data_;
  }
  if (login_data) {
    set_has_login_data();
    login_data_ = login_data;
  } else {
    clear_has_login_data();
    login_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.trustonic.tee_proxy.OpenSessionRequest.login_data)
}

// -------------------------------------------------------------------

// OpenSessionResponse

// required uint32 id = 1;
inline bool OpenSessionResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenSessionResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenSessionResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenSessionResponse::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 OpenSessionResponse::id() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.OpenSessionResponse.id)
  return id_;
}
inline void OpenSessionResponse::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.OpenSessionResponse.id)
}

// -------------------------------------------------------------------

// OpenTrustletRequest

// required uint32 spid = 1;
inline bool OpenTrustletRequest::has_spid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenTrustletRequest::set_has_spid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenTrustletRequest::clear_has_spid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenTrustletRequest::clear_spid() {
  spid_ = 0u;
  clear_has_spid();
}
inline ::google::protobuf::uint32 OpenTrustletRequest::spid() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.OpenTrustletRequest.spid)
  return spid_;
}
inline void OpenTrustletRequest::set_spid(::google::protobuf::uint32 value) {
  set_has_spid();
  spid_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.OpenTrustletRequest.spid)
}

// required bytes trustapp = 2;
inline bool OpenTrustletRequest::has_trustapp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenTrustletRequest::set_has_trustapp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenTrustletRequest::clear_has_trustapp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenTrustletRequest::clear_trustapp() {
  if (trustapp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trustapp_->clear();
  }
  clear_has_trustapp();
}
inline const ::std::string& OpenTrustletRequest::trustapp() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.OpenTrustletRequest.trustapp)
  return *trustapp_;
}
inline void OpenTrustletRequest::set_trustapp(const ::std::string& value) {
  set_has_trustapp();
  if (trustapp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trustapp_ = new ::std::string;
  }
  trustapp_->assign(value);
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.OpenTrustletRequest.trustapp)
}
inline void OpenTrustletRequest::set_trustapp(const char* value) {
  set_has_trustapp();
  if (trustapp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trustapp_ = new ::std::string;
  }
  trustapp_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.trustonic.tee_proxy.OpenTrustletRequest.trustapp)
}
inline void OpenTrustletRequest::set_trustapp(const void* value, size_t size) {
  set_has_trustapp();
  if (trustapp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trustapp_ = new ::std::string;
  }
  trustapp_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.trustonic.tee_proxy.OpenTrustletRequest.trustapp)
}
inline ::std::string* OpenTrustletRequest::mutable_trustapp() {
  set_has_trustapp();
  if (trustapp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    trustapp_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.OpenTrustletRequest.trustapp)
  return trustapp_;
}
inline ::std::string* OpenTrustletRequest::release_trustapp() {
  clear_has_trustapp();
  if (trustapp_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = trustapp_;
    trustapp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OpenTrustletRequest::set_allocated_trustapp(::std::string* trustapp) {
  if (trustapp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete trustapp_;
  }
  if (trustapp) {
    set_has_trustapp();
    trustapp_ = trustapp;
  } else {
    clear_has_trustapp();
    trustapp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.trustonic.tee_proxy.OpenTrustletRequest.trustapp)
}

// optional bytes tci = 3;
inline bool OpenTrustletRequest::has_tci() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpenTrustletRequest::set_has_tci() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpenTrustletRequest::clear_has_tci() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpenTrustletRequest::clear_tci() {
  if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_->clear();
  }
  clear_has_tci();
}
inline const ::std::string& OpenTrustletRequest::tci() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.OpenTrustletRequest.tci)
  return *tci_;
}
inline void OpenTrustletRequest::set_tci(const ::std::string& value) {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  tci_->assign(value);
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.OpenTrustletRequest.tci)
}
inline void OpenTrustletRequest::set_tci(const char* value) {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  tci_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.trustonic.tee_proxy.OpenTrustletRequest.tci)
}
inline void OpenTrustletRequest::set_tci(const void* value, size_t size) {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  tci_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.trustonic.tee_proxy.OpenTrustletRequest.tci)
}
inline ::std::string* OpenTrustletRequest::mutable_tci() {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.OpenTrustletRequest.tci)
  return tci_;
}
inline ::std::string* OpenTrustletRequest::release_tci() {
  clear_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tci_;
    tci_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void OpenTrustletRequest::set_allocated_tci(::std::string* tci) {
  if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tci_;
  }
  if (tci) {
    set_has_tci();
    tci_ = tci;
  } else {
    clear_has_tci();
    tci_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.trustonic.tee_proxy.OpenTrustletRequest.tci)
}

// -------------------------------------------------------------------

// OpenTrustletResponse

// required uint32 id = 1;
inline bool OpenTrustletResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenTrustletResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenTrustletResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenTrustletResponse::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 OpenTrustletResponse::id() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.OpenTrustletResponse.id)
  return id_;
}
inline void OpenTrustletResponse::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.OpenTrustletResponse.id)
}

// -------------------------------------------------------------------

// CloseSessionRequest

// required uint32 id = 1;
inline bool CloseSessionRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CloseSessionRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CloseSessionRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CloseSessionRequest::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 CloseSessionRequest::id() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.CloseSessionRequest.id)
  return id_;
}
inline void CloseSessionRequest::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.CloseSessionRequest.id)
}

// -------------------------------------------------------------------

// CloseSessionResponse

// -------------------------------------------------------------------

// NotifyRequest_Buffers

// required uint64 sva = 1;
inline bool NotifyRequest_Buffers::has_sva() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyRequest_Buffers::set_has_sva() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyRequest_Buffers::clear_has_sva() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyRequest_Buffers::clear_sva() {
  sva_ = GOOGLE_ULONGLONG(0);
  clear_has_sva();
}
inline ::google::protobuf::uint64 NotifyRequest_Buffers::sva() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.NotifyRequest.Buffers.sva)
  return sva_;
}
inline void NotifyRequest_Buffers::set_sva(::google::protobuf::uint64 value) {
  set_has_sva();
  sva_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.NotifyRequest.Buffers.sva)
}

// required bytes data = 2;
inline bool NotifyRequest_Buffers::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyRequest_Buffers::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyRequest_Buffers::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyRequest_Buffers::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& NotifyRequest_Buffers::data() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.NotifyRequest.Buffers.data)
  return *data_;
}
inline void NotifyRequest_Buffers::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.NotifyRequest.Buffers.data)
}
inline void NotifyRequest_Buffers::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.trustonic.tee_proxy.NotifyRequest.Buffers.data)
}
inline void NotifyRequest_Buffers::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.trustonic.tee_proxy.NotifyRequest.Buffers.data)
}
inline ::std::string* NotifyRequest_Buffers::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.NotifyRequest.Buffers.data)
  return data_;
}
inline ::std::string* NotifyRequest_Buffers::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NotifyRequest_Buffers::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.trustonic.tee_proxy.NotifyRequest.Buffers.data)
}

// -------------------------------------------------------------------

// NotifyRequest

// required uint32 sid = 1;
inline bool NotifyRequest::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NotifyRequest::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NotifyRequest::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NotifyRequest::clear_sid() {
  sid_ = 0u;
  clear_has_sid();
}
inline ::google::protobuf::uint32 NotifyRequest::sid() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.NotifyRequest.sid)
  return sid_;
}
inline void NotifyRequest::set_sid(::google::protobuf::uint32 value) {
  set_has_sid();
  sid_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.NotifyRequest.sid)
}

// optional bytes tci = 2;
inline bool NotifyRequest::has_tci() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NotifyRequest::set_has_tci() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NotifyRequest::clear_has_tci() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NotifyRequest::clear_tci() {
  if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_->clear();
  }
  clear_has_tci();
}
inline const ::std::string& NotifyRequest::tci() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.NotifyRequest.tci)
  return *tci_;
}
inline void NotifyRequest::set_tci(const ::std::string& value) {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  tci_->assign(value);
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.NotifyRequest.tci)
}
inline void NotifyRequest::set_tci(const char* value) {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  tci_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.trustonic.tee_proxy.NotifyRequest.tci)
}
inline void NotifyRequest::set_tci(const void* value, size_t size) {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  tci_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.trustonic.tee_proxy.NotifyRequest.tci)
}
inline ::std::string* NotifyRequest::mutable_tci() {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.NotifyRequest.tci)
  return tci_;
}
inline ::std::string* NotifyRequest::release_tci() {
  clear_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tci_;
    tci_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NotifyRequest::set_allocated_tci(::std::string* tci) {
  if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tci_;
  }
  if (tci) {
    set_has_tci();
    tci_ = tci;
  } else {
    clear_has_tci();
    tci_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.trustonic.tee_proxy.NotifyRequest.tci)
}

// repeated .com.trustonic.tee_proxy.NotifyRequest.Buffers buffers = 3;
inline int NotifyRequest::buffers_size() const {
  return buffers_.size();
}
inline void NotifyRequest::clear_buffers() {
  buffers_.Clear();
}
inline const ::com::trustonic::tee_proxy::NotifyRequest_Buffers& NotifyRequest::buffers(int index) const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.NotifyRequest.buffers)
  return buffers_.Get(index);
}
inline ::com::trustonic::tee_proxy::NotifyRequest_Buffers* NotifyRequest::mutable_buffers(int index) {
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.NotifyRequest.buffers)
  return buffers_.Mutable(index);
}
inline ::com::trustonic::tee_proxy::NotifyRequest_Buffers* NotifyRequest::add_buffers() {
  // @@protoc_insertion_point(field_add:com.trustonic.tee_proxy.NotifyRequest.buffers)
  return buffers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::NotifyRequest_Buffers >&
NotifyRequest::buffers() const {
  // @@protoc_insertion_point(field_list:com.trustonic.tee_proxy.NotifyRequest.buffers)
  return buffers_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::NotifyRequest_Buffers >*
NotifyRequest::mutable_buffers() {
  // @@protoc_insertion_point(field_mutable_list:com.trustonic.tee_proxy.NotifyRequest.buffers)
  return &buffers_;
}

// -------------------------------------------------------------------

// NotifyResponse

// -------------------------------------------------------------------

// WaitNotificationRequest

// required uint32 sid = 1;
inline bool WaitNotificationRequest::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WaitNotificationRequest::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WaitNotificationRequest::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WaitNotificationRequest::clear_sid() {
  sid_ = 0u;
  clear_has_sid();
}
inline ::google::protobuf::uint32 WaitNotificationRequest::sid() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.WaitNotificationRequest.sid)
  return sid_;
}
inline void WaitNotificationRequest::set_sid(::google::protobuf::uint32 value) {
  set_has_sid();
  sid_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.WaitNotificationRequest.sid)
}

// required sint32 timeout = 2;
inline bool WaitNotificationRequest::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WaitNotificationRequest::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WaitNotificationRequest::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WaitNotificationRequest::clear_timeout() {
  timeout_ = 0;
  clear_has_timeout();
}
inline ::google::protobuf::int32 WaitNotificationRequest::timeout() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.WaitNotificationRequest.timeout)
  return timeout_;
}
inline void WaitNotificationRequest::set_timeout(::google::protobuf::int32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.WaitNotificationRequest.timeout)
}

// required bool partial = 3;
inline bool WaitNotificationRequest::has_partial() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WaitNotificationRequest::set_has_partial() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WaitNotificationRequest::clear_has_partial() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WaitNotificationRequest::clear_partial() {
  partial_ = false;
  clear_has_partial();
}
inline bool WaitNotificationRequest::partial() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.WaitNotificationRequest.partial)
  return partial_;
}
inline void WaitNotificationRequest::set_partial(bool value) {
  set_has_partial();
  partial_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.WaitNotificationRequest.partial)
}

// -------------------------------------------------------------------

// WaitNotificationResponse_Buffers

// required uint64 sva = 1;
inline bool WaitNotificationResponse_Buffers::has_sva() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WaitNotificationResponse_Buffers::set_has_sva() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WaitNotificationResponse_Buffers::clear_has_sva() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WaitNotificationResponse_Buffers::clear_sva() {
  sva_ = GOOGLE_ULONGLONG(0);
  clear_has_sva();
}
inline ::google::protobuf::uint64 WaitNotificationResponse_Buffers::sva() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers.sva)
  return sva_;
}
inline void WaitNotificationResponse_Buffers::set_sva(::google::protobuf::uint64 value) {
  set_has_sva();
  sva_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers.sva)
}

// required bytes data = 2;
inline bool WaitNotificationResponse_Buffers::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WaitNotificationResponse_Buffers::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WaitNotificationResponse_Buffers::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WaitNotificationResponse_Buffers::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& WaitNotificationResponse_Buffers::data() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers.data)
  return *data_;
}
inline void WaitNotificationResponse_Buffers::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers.data)
}
inline void WaitNotificationResponse_Buffers::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers.data)
}
inline void WaitNotificationResponse_Buffers::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers.data)
}
inline ::std::string* WaitNotificationResponse_Buffers::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers.data)
  return data_;
}
inline ::std::string* WaitNotificationResponse_Buffers::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WaitNotificationResponse_Buffers::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers.data)
}

// -------------------------------------------------------------------

// WaitNotificationResponse

// optional bytes tci = 1;
inline bool WaitNotificationResponse::has_tci() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WaitNotificationResponse::set_has_tci() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WaitNotificationResponse::clear_has_tci() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WaitNotificationResponse::clear_tci() {
  if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_->clear();
  }
  clear_has_tci();
}
inline const ::std::string& WaitNotificationResponse::tci() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.WaitNotificationResponse.tci)
  return *tci_;
}
inline void WaitNotificationResponse::set_tci(const ::std::string& value) {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  tci_->assign(value);
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.WaitNotificationResponse.tci)
}
inline void WaitNotificationResponse::set_tci(const char* value) {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  tci_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.trustonic.tee_proxy.WaitNotificationResponse.tci)
}
inline void WaitNotificationResponse::set_tci(const void* value, size_t size) {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  tci_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.trustonic.tee_proxy.WaitNotificationResponse.tci)
}
inline ::std::string* WaitNotificationResponse::mutable_tci() {
  set_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tci_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.WaitNotificationResponse.tci)
  return tci_;
}
inline ::std::string* WaitNotificationResponse::release_tci() {
  clear_has_tci();
  if (tci_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tci_;
    tci_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void WaitNotificationResponse::set_allocated_tci(::std::string* tci) {
  if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tci_;
  }
  if (tci) {
    set_has_tci();
    tci_ = tci;
  } else {
    clear_has_tci();
    tci_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.trustonic.tee_proxy.WaitNotificationResponse.tci)
}

// repeated .com.trustonic.tee_proxy.WaitNotificationResponse.Buffers buffers = 2;
inline int WaitNotificationResponse::buffers_size() const {
  return buffers_.size();
}
inline void WaitNotificationResponse::clear_buffers() {
  buffers_.Clear();
}
inline const ::com::trustonic::tee_proxy::WaitNotificationResponse_Buffers& WaitNotificationResponse::buffers(int index) const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.WaitNotificationResponse.buffers)
  return buffers_.Get(index);
}
inline ::com::trustonic::tee_proxy::WaitNotificationResponse_Buffers* WaitNotificationResponse::mutable_buffers(int index) {
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.WaitNotificationResponse.buffers)
  return buffers_.Mutable(index);
}
inline ::com::trustonic::tee_proxy::WaitNotificationResponse_Buffers* WaitNotificationResponse::add_buffers() {
  // @@protoc_insertion_point(field_add:com.trustonic.tee_proxy.WaitNotificationResponse.buffers)
  return buffers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::WaitNotificationResponse_Buffers >&
WaitNotificationResponse::buffers() const {
  // @@protoc_insertion_point(field_list:com.trustonic.tee_proxy.WaitNotificationResponse.buffers)
  return buffers_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::WaitNotificationResponse_Buffers >*
WaitNotificationResponse::mutable_buffers() {
  // @@protoc_insertion_point(field_mutable_list:com.trustonic.tee_proxy.WaitNotificationResponse.buffers)
  return &buffers_;
}

// -------------------------------------------------------------------

// MapRequest_Buffers

// required uint32 len = 1;
inline bool MapRequest_Buffers::has_len() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapRequest_Buffers::set_has_len() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapRequest_Buffers::clear_has_len() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapRequest_Buffers::clear_len() {
  len_ = 0u;
  clear_has_len();
}
inline ::google::protobuf::uint32 MapRequest_Buffers::len() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.MapRequest.Buffers.len)
  return len_;
}
inline void MapRequest_Buffers::set_len(::google::protobuf::uint32 value) {
  set_has_len();
  len_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.MapRequest.Buffers.len)
}

// required uint32 flags = 2;
inline bool MapRequest_Buffers::has_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapRequest_Buffers::set_has_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapRequest_Buffers::clear_has_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapRequest_Buffers::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 MapRequest_Buffers::flags() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.MapRequest.Buffers.flags)
  return flags_;
}
inline void MapRequest_Buffers::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.MapRequest.Buffers.flags)
}

// -------------------------------------------------------------------

// MapRequest

// required uint32 sid = 1;
inline bool MapRequest::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapRequest::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapRequest::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapRequest::clear_sid() {
  sid_ = 0u;
  clear_has_sid();
}
inline ::google::protobuf::uint32 MapRequest::sid() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.MapRequest.sid)
  return sid_;
}
inline void MapRequest::set_sid(::google::protobuf::uint32 value) {
  set_has_sid();
  sid_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.MapRequest.sid)
}

// repeated .com.trustonic.tee_proxy.MapRequest.Buffers buffers = 2;
inline int MapRequest::buffers_size() const {
  return buffers_.size();
}
inline void MapRequest::clear_buffers() {
  buffers_.Clear();
}
inline const ::com::trustonic::tee_proxy::MapRequest_Buffers& MapRequest::buffers(int index) const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.MapRequest.buffers)
  return buffers_.Get(index);
}
inline ::com::trustonic::tee_proxy::MapRequest_Buffers* MapRequest::mutable_buffers(int index) {
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.MapRequest.buffers)
  return buffers_.Mutable(index);
}
inline ::com::trustonic::tee_proxy::MapRequest_Buffers* MapRequest::add_buffers() {
  // @@protoc_insertion_point(field_add:com.trustonic.tee_proxy.MapRequest.buffers)
  return buffers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::MapRequest_Buffers >&
MapRequest::buffers() const {
  // @@protoc_insertion_point(field_list:com.trustonic.tee_proxy.MapRequest.buffers)
  return buffers_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::MapRequest_Buffers >*
MapRequest::mutable_buffers() {
  // @@protoc_insertion_point(field_mutable_list:com.trustonic.tee_proxy.MapRequest.buffers)
  return &buffers_;
}

// -------------------------------------------------------------------

// MapResponse_Buffers

// required uint64 sva = 1;
inline bool MapResponse_Buffers::has_sva() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapResponse_Buffers::set_has_sva() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapResponse_Buffers::clear_has_sva() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapResponse_Buffers::clear_sva() {
  sva_ = GOOGLE_ULONGLONG(0);
  clear_has_sva();
}
inline ::google::protobuf::uint64 MapResponse_Buffers::sva() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.MapResponse.Buffers.sva)
  return sva_;
}
inline void MapResponse_Buffers::set_sva(::google::protobuf::uint64 value) {
  set_has_sva();
  sva_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.MapResponse.Buffers.sva)
}

// -------------------------------------------------------------------

// MapResponse

// repeated .com.trustonic.tee_proxy.MapResponse.Buffers buffers = 1;
inline int MapResponse::buffers_size() const {
  return buffers_.size();
}
inline void MapResponse::clear_buffers() {
  buffers_.Clear();
}
inline const ::com::trustonic::tee_proxy::MapResponse_Buffers& MapResponse::buffers(int index) const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.MapResponse.buffers)
  return buffers_.Get(index);
}
inline ::com::trustonic::tee_proxy::MapResponse_Buffers* MapResponse::mutable_buffers(int index) {
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.MapResponse.buffers)
  return buffers_.Mutable(index);
}
inline ::com::trustonic::tee_proxy::MapResponse_Buffers* MapResponse::add_buffers() {
  // @@protoc_insertion_point(field_add:com.trustonic.tee_proxy.MapResponse.buffers)
  return buffers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::MapResponse_Buffers >&
MapResponse::buffers() const {
  // @@protoc_insertion_point(field_list:com.trustonic.tee_proxy.MapResponse.buffers)
  return buffers_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::MapResponse_Buffers >*
MapResponse::mutable_buffers() {
  // @@protoc_insertion_point(field_mutable_list:com.trustonic.tee_proxy.MapResponse.buffers)
  return &buffers_;
}

// -------------------------------------------------------------------

// UnmapRequest_Buffers

// required uint64 sva = 1;
inline bool UnmapRequest_Buffers::has_sva() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnmapRequest_Buffers::set_has_sva() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnmapRequest_Buffers::clear_has_sva() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnmapRequest_Buffers::clear_sva() {
  sva_ = GOOGLE_ULONGLONG(0);
  clear_has_sva();
}
inline ::google::protobuf::uint64 UnmapRequest_Buffers::sva() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.UnmapRequest.Buffers.sva)
  return sva_;
}
inline void UnmapRequest_Buffers::set_sva(::google::protobuf::uint64 value) {
  set_has_sva();
  sva_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.UnmapRequest.Buffers.sva)
}

// -------------------------------------------------------------------

// UnmapRequest

// required uint32 sid = 1;
inline bool UnmapRequest::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnmapRequest::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnmapRequest::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnmapRequest::clear_sid() {
  sid_ = 0u;
  clear_has_sid();
}
inline ::google::protobuf::uint32 UnmapRequest::sid() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.UnmapRequest.sid)
  return sid_;
}
inline void UnmapRequest::set_sid(::google::protobuf::uint32 value) {
  set_has_sid();
  sid_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.UnmapRequest.sid)
}

// repeated .com.trustonic.tee_proxy.UnmapRequest.Buffers buffers = 2;
inline int UnmapRequest::buffers_size() const {
  return buffers_.size();
}
inline void UnmapRequest::clear_buffers() {
  buffers_.Clear();
}
inline const ::com::trustonic::tee_proxy::UnmapRequest_Buffers& UnmapRequest::buffers(int index) const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.UnmapRequest.buffers)
  return buffers_.Get(index);
}
inline ::com::trustonic::tee_proxy::UnmapRequest_Buffers* UnmapRequest::mutable_buffers(int index) {
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.UnmapRequest.buffers)
  return buffers_.Mutable(index);
}
inline ::com::trustonic::tee_proxy::UnmapRequest_Buffers* UnmapRequest::add_buffers() {
  // @@protoc_insertion_point(field_add:com.trustonic.tee_proxy.UnmapRequest.buffers)
  return buffers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::UnmapRequest_Buffers >&
UnmapRequest::buffers() const {
  // @@protoc_insertion_point(field_list:com.trustonic.tee_proxy.UnmapRequest.buffers)
  return buffers_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::trustonic::tee_proxy::UnmapRequest_Buffers >*
UnmapRequest::mutable_buffers() {
  // @@protoc_insertion_point(field_mutable_list:com.trustonic.tee_proxy.UnmapRequest.buffers)
  return &buffers_;
}

// -------------------------------------------------------------------

// UnmapResponse

// -------------------------------------------------------------------

// GetErrorRequest

// required uint32 sid = 1;
inline bool GetErrorRequest::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetErrorRequest::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetErrorRequest::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetErrorRequest::clear_sid() {
  sid_ = 0u;
  clear_has_sid();
}
inline ::google::protobuf::uint32 GetErrorRequest::sid() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.GetErrorRequest.sid)
  return sid_;
}
inline void GetErrorRequest::set_sid(::google::protobuf::uint32 value) {
  set_has_sid();
  sid_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.GetErrorRequest.sid)
}

// -------------------------------------------------------------------

// GetErrorResponse

// required sint32 exit_code = 1;
inline bool GetErrorResponse::has_exit_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetErrorResponse::set_has_exit_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetErrorResponse::clear_has_exit_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetErrorResponse::clear_exit_code() {
  exit_code_ = 0;
  clear_has_exit_code();
}
inline ::google::protobuf::int32 GetErrorResponse::exit_code() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.GetErrorResponse.exit_code)
  return exit_code_;
}
inline void GetErrorResponse::set_exit_code(::google::protobuf::int32 value) {
  set_has_exit_code();
  exit_code_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.GetErrorResponse.exit_code)
}

// -------------------------------------------------------------------

// GetVersionRequest

// -------------------------------------------------------------------

// GetVersionResponse

// required string product_id = 1;
inline bool GetVersionResponse::has_product_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetVersionResponse::set_has_product_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetVersionResponse::clear_has_product_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetVersionResponse::clear_product_id() {
  if (product_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_->clear();
  }
  clear_has_product_id();
}
inline const ::std::string& GetVersionResponse::product_id() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.GetVersionResponse.product_id)
  return *product_id_;
}
inline void GetVersionResponse::set_product_id(const ::std::string& value) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(value);
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.GetVersionResponse.product_id)
}
inline void GetVersionResponse::set_product_id(const char* value) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:com.trustonic.tee_proxy.GetVersionResponse.product_id)
}
inline void GetVersionResponse::set_product_id(const char* value, size_t size) {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_ = new ::std::string;
  }
  product_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:com.trustonic.tee_proxy.GetVersionResponse.product_id)
}
inline ::std::string* GetVersionResponse::mutable_product_id() {
  set_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    product_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:com.trustonic.tee_proxy.GetVersionResponse.product_id)
  return product_id_;
}
inline ::std::string* GetVersionResponse::release_product_id() {
  clear_has_product_id();
  if (product_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = product_id_;
    product_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GetVersionResponse::set_allocated_product_id(::std::string* product_id) {
  if (product_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete product_id_;
  }
  if (product_id) {
    set_has_product_id();
    product_id_ = product_id;
  } else {
    clear_has_product_id();
    product_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:com.trustonic.tee_proxy.GetVersionResponse.product_id)
}

// required uint32 mci = 2;
inline bool GetVersionResponse::has_mci() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetVersionResponse::set_has_mci() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetVersionResponse::clear_has_mci() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetVersionResponse::clear_mci() {
  mci_ = 0u;
  clear_has_mci();
}
inline ::google::protobuf::uint32 GetVersionResponse::mci() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.GetVersionResponse.mci)
  return mci_;
}
inline void GetVersionResponse::set_mci(::google::protobuf::uint32 value) {
  set_has_mci();
  mci_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.GetVersionResponse.mci)
}

// required uint32 so = 3;
inline bool GetVersionResponse::has_so() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetVersionResponse::set_has_so() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetVersionResponse::clear_has_so() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetVersionResponse::clear_so() {
  so_ = 0u;
  clear_has_so();
}
inline ::google::protobuf::uint32 GetVersionResponse::so() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.GetVersionResponse.so)
  return so_;
}
inline void GetVersionResponse::set_so(::google::protobuf::uint32 value) {
  set_has_so();
  so_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.GetVersionResponse.so)
}

// required uint32 mclf = 4;
inline bool GetVersionResponse::has_mclf() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetVersionResponse::set_has_mclf() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetVersionResponse::clear_has_mclf() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetVersionResponse::clear_mclf() {
  mclf_ = 0u;
  clear_has_mclf();
}
inline ::google::protobuf::uint32 GetVersionResponse::mclf() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.GetVersionResponse.mclf)
  return mclf_;
}
inline void GetVersionResponse::set_mclf(::google::protobuf::uint32 value) {
  set_has_mclf();
  mclf_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.GetVersionResponse.mclf)
}

// required uint32 container = 5;
inline bool GetVersionResponse::has_container() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetVersionResponse::set_has_container() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetVersionResponse::clear_has_container() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetVersionResponse::clear_container() {
  container_ = 0u;
  clear_has_container();
}
inline ::google::protobuf::uint32 GetVersionResponse::container() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.GetVersionResponse.container)
  return container_;
}
inline void GetVersionResponse::set_container(::google::protobuf::uint32 value) {
  set_has_container();
  container_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.GetVersionResponse.container)
}

// required uint32 mc_config = 6;
inline bool GetVersionResponse::has_mc_config() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetVersionResponse::set_has_mc_config() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetVersionResponse::clear_has_mc_config() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetVersionResponse::clear_mc_config() {
  mc_config_ = 0u;
  clear_has_mc_config();
}
inline ::google::protobuf::uint32 GetVersionResponse::mc_config() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.GetVersionResponse.mc_config)
  return mc_config_;
}
inline void GetVersionResponse::set_mc_config(::google::protobuf::uint32 value) {
  set_has_mc_config();
  mc_config_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.GetVersionResponse.mc_config)
}

// required uint32 tl_api = 7;
inline bool GetVersionResponse::has_tl_api() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetVersionResponse::set_has_tl_api() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetVersionResponse::clear_has_tl_api() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetVersionResponse::clear_tl_api() {
  tl_api_ = 0u;
  clear_has_tl_api();
}
inline ::google::protobuf::uint32 GetVersionResponse::tl_api() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.GetVersionResponse.tl_api)
  return tl_api_;
}
inline void GetVersionResponse::set_tl_api(::google::protobuf::uint32 value) {
  set_has_tl_api();
  tl_api_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.GetVersionResponse.tl_api)
}

// required uint32 dr_api = 8;
inline bool GetVersionResponse::has_dr_api() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetVersionResponse::set_has_dr_api() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetVersionResponse::clear_has_dr_api() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetVersionResponse::clear_dr_api() {
  dr_api_ = 0u;
  clear_has_dr_api();
}
inline ::google::protobuf::uint32 GetVersionResponse::dr_api() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.GetVersionResponse.dr_api)
  return dr_api_;
}
inline void GetVersionResponse::set_dr_api(::google::protobuf::uint32 value) {
  set_has_dr_api();
  dr_api_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.GetVersionResponse.dr_api)
}

// required uint32 nwd = 9;
inline bool GetVersionResponse::has_nwd() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GetVersionResponse::set_has_nwd() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GetVersionResponse::clear_has_nwd() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GetVersionResponse::clear_nwd() {
  nwd_ = 0u;
  clear_has_nwd();
}
inline ::google::protobuf::uint32 GetVersionResponse::nwd() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.GetVersionResponse.nwd)
  return nwd_;
}
inline void GetVersionResponse::set_nwd(::google::protobuf::uint32 value) {
  set_has_nwd();
  nwd_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.GetVersionResponse.nwd)
}

// -------------------------------------------------------------------

// GpRequestCancellationRequest

// required uint32 sid = 1;
inline bool GpRequestCancellationRequest::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GpRequestCancellationRequest::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GpRequestCancellationRequest::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GpRequestCancellationRequest::clear_sid() {
  sid_ = 0u;
  clear_has_sid();
}
inline ::google::protobuf::uint32 GpRequestCancellationRequest::sid() const {
  // @@protoc_insertion_point(field_get:com.trustonic.tee_proxy.GpRequestCancellationRequest.sid)
  return sid_;
}
inline void GpRequestCancellationRequest::set_sid(::google::protobuf::uint32 value) {
  set_has_sid();
  sid_ = value;
  // @@protoc_insertion_point(field_set:com.trustonic.tee_proxy.GpRequestCancellationRequest.sid)
}

// -------------------------------------------------------------------

// GpRequestCancellationResponse


// @@protoc_insertion_point(namespace_scope)

}  // namespace tee_proxy
}  // namespace trustonic
}  // namespace com

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mc_2eproto__INCLUDED
