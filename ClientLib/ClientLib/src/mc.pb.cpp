/*
 * Copyright (c) 2013-2015 TRUSTONIC LIMITED
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the TRUSTONIC LIMITED nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mc.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "mc.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace trustonic {
namespace tee_proxy {

void protobuf_ShutdownFile_mc_2eproto() {
  delete OpenSessionRequest::default_instance_;
  delete OpenSessionResponse::default_instance_;
  delete OpenTrustletRequest::default_instance_;
  delete OpenTrustletResponse::default_instance_;
  delete CloseSessionRequest::default_instance_;
  delete CloseSessionResponse::default_instance_;
  delete NotifyRequest::default_instance_;
  delete NotifyRequest_Buffers::default_instance_;
  delete NotifyResponse::default_instance_;
  delete WaitNotificationRequest::default_instance_;
  delete WaitNotificationResponse::default_instance_;
  delete WaitNotificationResponse_Buffers::default_instance_;
  delete MapRequest::default_instance_;
  delete MapRequest_Buffers::default_instance_;
  delete MapResponse::default_instance_;
  delete MapResponse_Buffers::default_instance_;
  delete UnmapRequest::default_instance_;
  delete UnmapRequest_Buffers::default_instance_;
  delete UnmapResponse::default_instance_;
  delete GetErrorRequest::default_instance_;
  delete GetErrorResponse::default_instance_;
  delete GetVersionRequest::default_instance_;
  delete GetVersionResponse::default_instance_;
  delete GpRequestCancellationRequest::default_instance_;
  delete GpRequestCancellationResponse::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_mc_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_mc_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  OpenSessionRequest::default_instance_ = new OpenSessionRequest();
  OpenSessionResponse::default_instance_ = new OpenSessionResponse();
  OpenTrustletRequest::default_instance_ = new OpenTrustletRequest();
  OpenTrustletResponse::default_instance_ = new OpenTrustletResponse();
  CloseSessionRequest::default_instance_ = new CloseSessionRequest();
  CloseSessionResponse::default_instance_ = new CloseSessionResponse();
  NotifyRequest::default_instance_ = new NotifyRequest();
  NotifyRequest_Buffers::default_instance_ = new NotifyRequest_Buffers();
  NotifyResponse::default_instance_ = new NotifyResponse();
  WaitNotificationRequest::default_instance_ = new WaitNotificationRequest();
  WaitNotificationResponse::default_instance_ = new WaitNotificationResponse();
  WaitNotificationResponse_Buffers::default_instance_ = new WaitNotificationResponse_Buffers();
  MapRequest::default_instance_ = new MapRequest();
  MapRequest_Buffers::default_instance_ = new MapRequest_Buffers();
  MapResponse::default_instance_ = new MapResponse();
  MapResponse_Buffers::default_instance_ = new MapResponse_Buffers();
  UnmapRequest::default_instance_ = new UnmapRequest();
  UnmapRequest_Buffers::default_instance_ = new UnmapRequest_Buffers();
  UnmapResponse::default_instance_ = new UnmapResponse();
  GetErrorRequest::default_instance_ = new GetErrorRequest();
  GetErrorResponse::default_instance_ = new GetErrorResponse();
  GetVersionRequest::default_instance_ = new GetVersionRequest();
  GetVersionResponse::default_instance_ = new GetVersionResponse();
  GpRequestCancellationRequest::default_instance_ = new GpRequestCancellationRequest();
  GpRequestCancellationResponse::default_instance_ = new GpRequestCancellationResponse();
  OpenSessionRequest::default_instance_->InitAsDefaultInstance();
  OpenSessionResponse::default_instance_->InitAsDefaultInstance();
  OpenTrustletRequest::default_instance_->InitAsDefaultInstance();
  OpenTrustletResponse::default_instance_->InitAsDefaultInstance();
  CloseSessionRequest::default_instance_->InitAsDefaultInstance();
  CloseSessionResponse::default_instance_->InitAsDefaultInstance();
  NotifyRequest::default_instance_->InitAsDefaultInstance();
  NotifyRequest_Buffers::default_instance_->InitAsDefaultInstance();
  NotifyResponse::default_instance_->InitAsDefaultInstance();
  WaitNotificationRequest::default_instance_->InitAsDefaultInstance();
  WaitNotificationResponse::default_instance_->InitAsDefaultInstance();
  WaitNotificationResponse_Buffers::default_instance_->InitAsDefaultInstance();
  MapRequest::default_instance_->InitAsDefaultInstance();
  MapRequest_Buffers::default_instance_->InitAsDefaultInstance();
  MapResponse::default_instance_->InitAsDefaultInstance();
  MapResponse_Buffers::default_instance_->InitAsDefaultInstance();
  UnmapRequest::default_instance_->InitAsDefaultInstance();
  UnmapRequest_Buffers::default_instance_->InitAsDefaultInstance();
  UnmapResponse::default_instance_->InitAsDefaultInstance();
  GetErrorRequest::default_instance_->InitAsDefaultInstance();
  GetErrorResponse::default_instance_->InitAsDefaultInstance();
  GetVersionRequest::default_instance_->InitAsDefaultInstance();
  GetVersionResponse::default_instance_->InitAsDefaultInstance();
  GpRequestCancellationRequest::default_instance_->InitAsDefaultInstance();
  GpRequestCancellationResponse::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_mc_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_mc_2eproto_once_);
void protobuf_AddDesc_mc_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_mc_2eproto_once_,
                 &protobuf_AddDesc_mc_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_mc_2eproto {
  StaticDescriptorInitializer_mc_2eproto() {
    protobuf_AddDesc_mc_2eproto();
  }
} static_descriptor_initializer_mc_2eproto_;
#endif
bool LoginType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int OpenSessionRequest::kUuidFieldNumber;
const int OpenSessionRequest::kIsGpUuidFieldNumber;
const int OpenSessionRequest::kTciFieldNumber;
const int OpenSessionRequest::kLoginTypeFieldNumber;
const int OpenSessionRequest::kLoginDataFieldNumber;
#endif  // !_MSC_VER

OpenSessionRequest::OpenSessionRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.OpenSessionRequest)
}

void OpenSessionRequest::InitAsDefaultInstance() {
}

OpenSessionRequest::OpenSessionRequest(const OpenSessionRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.OpenSessionRequest)
}

void OpenSessionRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  is_gp_uuid_ = false;
  tci_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  login_type_ = 0;
  login_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenSessionRequest::~OpenSessionRequest() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.OpenSessionRequest)
  SharedDtor();
}

void OpenSessionRequest::SharedDtor() {
  if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete uuid_;
  }
  if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tci_;
  }
  if (login_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete login_data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OpenSessionRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OpenSessionRequest& OpenSessionRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

OpenSessionRequest* OpenSessionRequest::default_instance_ = NULL;

OpenSessionRequest* OpenSessionRequest::New() const {
  return new OpenSessionRequest;
}

void OpenSessionRequest::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<OpenSessionRequest*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(is_gp_uuid_, login_type_);
    if (has_uuid()) {
      if (uuid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        uuid_->clear();
      }
    }
    if (has_tci()) {
      if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        tci_->clear();
      }
    }
    if (has_login_data()) {
      if (login_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        login_data_->clear();
      }
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool OpenSessionRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.OpenSessionRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes uuid = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_is_gp_uuid;
        break;
      }

      // required bool is_gp_uuid = 2;
      case 2: {
        if (tag == 16) {
         parse_is_gp_uuid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_gp_uuid_)));
          set_has_is_gp_uuid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tci;
        break;
      }

      // optional bytes tci = 3;
      case 3: {
        if (tag == 26) {
         parse_tci:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_tci()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_login_type;
        break;
      }

      // required .com.trustonic.tee_proxy.LoginType login_type = 4;
      case 4: {
        if (tag == 32) {
         parse_login_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::com::trustonic::tee_proxy::LoginType_IsValid(value)) {
            set_login_type(static_cast< ::com::trustonic::tee_proxy::LoginType >(value));
          } else {
            unknown_fields_stream.WriteVarint32(tag);
            unknown_fields_stream.WriteVarint32(value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_login_data;
        break;
      }

      // required bytes login_data = 5;
      case 5: {
        if (tag == 42) {
         parse_login_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_login_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.OpenSessionRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.OpenSessionRequest)
  return false;
#undef DO_
}

void OpenSessionRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.OpenSessionRequest)
  // required bytes uuid = 1;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->uuid(), output);
  }

  // required bool is_gp_uuid = 2;
  if (has_is_gp_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_gp_uuid(), output);
  }

  // optional bytes tci = 3;
  if (has_tci()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->tci(), output);
  }

  // required .com.trustonic.tee_proxy.LoginType login_type = 4;
  if (has_login_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->login_type(), output);
  }

  // required bytes login_data = 5;
  if (has_login_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->login_data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.OpenSessionRequest)
}

int OpenSessionRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bytes uuid = 1;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

    // required bool is_gp_uuid = 2;
    if (has_is_gp_uuid()) {
      total_size += 1 + 1;
    }

    // optional bytes tci = 3;
    if (has_tci()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->tci());
    }

    // required .com.trustonic.tee_proxy.LoginType login_type = 4;
    if (has_login_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->login_type());
    }

    // required bytes login_data = 5;
    if (has_login_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->login_data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenSessionRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OpenSessionRequest*>(&from));
}

void OpenSessionRequest::MergeFrom(const OpenSessionRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_uuid()) {
      set_uuid(from.uuid());
    }
    if (from.has_is_gp_uuid()) {
      set_is_gp_uuid(from.is_gp_uuid());
    }
    if (from.has_tci()) {
      set_tci(from.tci());
    }
    if (from.has_login_type()) {
      set_login_type(from.login_type());
    }
    if (from.has_login_data()) {
      set_login_data(from.login_data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void OpenSessionRequest::CopyFrom(const OpenSessionRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenSessionRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000001b) != 0x0000001b) return false;

  return true;
}

void OpenSessionRequest::Swap(OpenSessionRequest* other) {
  if (other != this) {
    std::swap(uuid_, other->uuid_);
    std::swap(is_gp_uuid_, other->is_gp_uuid_);
    std::swap(tci_, other->tci_);
    std::swap(login_type_, other->login_type_);
    std::swap(login_data_, other->login_data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OpenSessionRequest::GetTypeName() const {
  return "com.trustonic.tee_proxy.OpenSessionRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int OpenSessionResponse::kIdFieldNumber;
#endif  // !_MSC_VER

OpenSessionResponse::OpenSessionResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.OpenSessionResponse)
}

void OpenSessionResponse::InitAsDefaultInstance() {
}

OpenSessionResponse::OpenSessionResponse(const OpenSessionResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.OpenSessionResponse)
}

void OpenSessionResponse::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenSessionResponse::~OpenSessionResponse() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.OpenSessionResponse)
  SharedDtor();
}

void OpenSessionResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OpenSessionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OpenSessionResponse& OpenSessionResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

OpenSessionResponse* OpenSessionResponse::default_instance_ = NULL;

OpenSessionResponse* OpenSessionResponse::New() const {
  return new OpenSessionResponse;
}

void OpenSessionResponse::Clear() {
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool OpenSessionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.OpenSessionResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.OpenSessionResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.OpenSessionResponse)
  return false;
#undef DO_
}

void OpenSessionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.OpenSessionResponse)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.OpenSessionResponse)
}

int OpenSessionResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenSessionResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OpenSessionResponse*>(&from));
}

void OpenSessionResponse::MergeFrom(const OpenSessionResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void OpenSessionResponse::CopyFrom(const OpenSessionResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenSessionResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void OpenSessionResponse::Swap(OpenSessionResponse* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OpenSessionResponse::GetTypeName() const {
  return "com.trustonic.tee_proxy.OpenSessionResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int OpenTrustletRequest::kSpidFieldNumber;
const int OpenTrustletRequest::kTrustappFieldNumber;
const int OpenTrustletRequest::kTciFieldNumber;
#endif  // !_MSC_VER

OpenTrustletRequest::OpenTrustletRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.OpenTrustletRequest)
}

void OpenTrustletRequest::InitAsDefaultInstance() {
}

OpenTrustletRequest::OpenTrustletRequest(const OpenTrustletRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.OpenTrustletRequest)
}

void OpenTrustletRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  spid_ = 0u;
  trustapp_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  tci_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenTrustletRequest::~OpenTrustletRequest() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.OpenTrustletRequest)
  SharedDtor();
}

void OpenTrustletRequest::SharedDtor() {
  if (trustapp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete trustapp_;
  }
  if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tci_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OpenTrustletRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OpenTrustletRequest& OpenTrustletRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

OpenTrustletRequest* OpenTrustletRequest::default_instance_ = NULL;

OpenTrustletRequest* OpenTrustletRequest::New() const {
  return new OpenTrustletRequest;
}

void OpenTrustletRequest::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    spid_ = 0u;
    if (has_trustapp()) {
      if (trustapp_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        trustapp_->clear();
      }
    }
    if (has_tci()) {
      if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        tci_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool OpenTrustletRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.OpenTrustletRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 spid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &spid_)));
          set_has_spid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_trustapp;
        break;
      }

      // required bytes trustapp = 2;
      case 2: {
        if (tag == 18) {
         parse_trustapp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_trustapp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tci;
        break;
      }

      // optional bytes tci = 3;
      case 3: {
        if (tag == 26) {
         parse_tci:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_tci()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.OpenTrustletRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.OpenTrustletRequest)
  return false;
#undef DO_
}

void OpenTrustletRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.OpenTrustletRequest)
  // required uint32 spid = 1;
  if (has_spid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->spid(), output);
  }

  // required bytes trustapp = 2;
  if (has_trustapp()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->trustapp(), output);
  }

  // optional bytes tci = 3;
  if (has_tci()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->tci(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.OpenTrustletRequest)
}

int OpenTrustletRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 spid = 1;
    if (has_spid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->spid());
    }

    // required bytes trustapp = 2;
    if (has_trustapp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->trustapp());
    }

    // optional bytes tci = 3;
    if (has_tci()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->tci());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenTrustletRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OpenTrustletRequest*>(&from));
}

void OpenTrustletRequest::MergeFrom(const OpenTrustletRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_spid()) {
      set_spid(from.spid());
    }
    if (from.has_trustapp()) {
      set_trustapp(from.trustapp());
    }
    if (from.has_tci()) {
      set_tci(from.tci());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void OpenTrustletRequest::CopyFrom(const OpenTrustletRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenTrustletRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void OpenTrustletRequest::Swap(OpenTrustletRequest* other) {
  if (other != this) {
    std::swap(spid_, other->spid_);
    std::swap(trustapp_, other->trustapp_);
    std::swap(tci_, other->tci_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OpenTrustletRequest::GetTypeName() const {
  return "com.trustonic.tee_proxy.OpenTrustletRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int OpenTrustletResponse::kIdFieldNumber;
#endif  // !_MSC_VER

OpenTrustletResponse::OpenTrustletResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.OpenTrustletResponse)
}

void OpenTrustletResponse::InitAsDefaultInstance() {
}

OpenTrustletResponse::OpenTrustletResponse(const OpenTrustletResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.OpenTrustletResponse)
}

void OpenTrustletResponse::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OpenTrustletResponse::~OpenTrustletResponse() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.OpenTrustletResponse)
  SharedDtor();
}

void OpenTrustletResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void OpenTrustletResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OpenTrustletResponse& OpenTrustletResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

OpenTrustletResponse* OpenTrustletResponse::default_instance_ = NULL;

OpenTrustletResponse* OpenTrustletResponse::New() const {
  return new OpenTrustletResponse;
}

void OpenTrustletResponse::Clear() {
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool OpenTrustletResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.OpenTrustletResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.OpenTrustletResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.OpenTrustletResponse)
  return false;
#undef DO_
}

void OpenTrustletResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.OpenTrustletResponse)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.OpenTrustletResponse)
}

int OpenTrustletResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OpenTrustletResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OpenTrustletResponse*>(&from));
}

void OpenTrustletResponse::MergeFrom(const OpenTrustletResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void OpenTrustletResponse::CopyFrom(const OpenTrustletResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OpenTrustletResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void OpenTrustletResponse::Swap(OpenTrustletResponse* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OpenTrustletResponse::GetTypeName() const {
  return "com.trustonic.tee_proxy.OpenTrustletResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int CloseSessionRequest::kIdFieldNumber;
#endif  // !_MSC_VER

CloseSessionRequest::CloseSessionRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.CloseSessionRequest)
}

void CloseSessionRequest::InitAsDefaultInstance() {
}

CloseSessionRequest::CloseSessionRequest(const CloseSessionRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.CloseSessionRequest)
}

void CloseSessionRequest::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CloseSessionRequest::~CloseSessionRequest() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.CloseSessionRequest)
  SharedDtor();
}

void CloseSessionRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CloseSessionRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CloseSessionRequest& CloseSessionRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

CloseSessionRequest* CloseSessionRequest::default_instance_ = NULL;

CloseSessionRequest* CloseSessionRequest::New() const {
  return new CloseSessionRequest;
}

void CloseSessionRequest::Clear() {
  id_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CloseSessionRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.CloseSessionRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.CloseSessionRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.CloseSessionRequest)
  return false;
#undef DO_
}

void CloseSessionRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.CloseSessionRequest)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.CloseSessionRequest)
}

int CloseSessionRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CloseSessionRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CloseSessionRequest*>(&from));
}

void CloseSessionRequest::MergeFrom(const CloseSessionRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CloseSessionRequest::CopyFrom(const CloseSessionRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CloseSessionRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CloseSessionRequest::Swap(CloseSessionRequest* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CloseSessionRequest::GetTypeName() const {
  return "com.trustonic.tee_proxy.CloseSessionRequest";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

CloseSessionResponse::CloseSessionResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.CloseSessionResponse)
}

void CloseSessionResponse::InitAsDefaultInstance() {
}

CloseSessionResponse::CloseSessionResponse(const CloseSessionResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.CloseSessionResponse)
}

void CloseSessionResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CloseSessionResponse::~CloseSessionResponse() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.CloseSessionResponse)
  SharedDtor();
}

void CloseSessionResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void CloseSessionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const CloseSessionResponse& CloseSessionResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

CloseSessionResponse* CloseSessionResponse::default_instance_ = NULL;

CloseSessionResponse* CloseSessionResponse::New() const {
  return new CloseSessionResponse;
}

void CloseSessionResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool CloseSessionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.CloseSessionResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.CloseSessionResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.CloseSessionResponse)
  return false;
#undef DO_
}

void CloseSessionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.CloseSessionResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.CloseSessionResponse)
}

int CloseSessionResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CloseSessionResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const CloseSessionResponse*>(&from));
}

void CloseSessionResponse::MergeFrom(const CloseSessionResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void CloseSessionResponse::CopyFrom(const CloseSessionResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CloseSessionResponse::IsInitialized() const {

  return true;
}

void CloseSessionResponse::Swap(CloseSessionResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string CloseSessionResponse::GetTypeName() const {
  return "com.trustonic.tee_proxy.CloseSessionResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int NotifyRequest_Buffers::kSvaFieldNumber;
const int NotifyRequest_Buffers::kDataFieldNumber;
#endif  // !_MSC_VER

NotifyRequest_Buffers::NotifyRequest_Buffers()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.NotifyRequest.Buffers)
}

void NotifyRequest_Buffers::InitAsDefaultInstance() {
}

NotifyRequest_Buffers::NotifyRequest_Buffers(const NotifyRequest_Buffers& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.NotifyRequest.Buffers)
}

void NotifyRequest_Buffers::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  sva_ = GOOGLE_ULONGLONG(0);
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyRequest_Buffers::~NotifyRequest_Buffers() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.NotifyRequest.Buffers)
  SharedDtor();
}

void NotifyRequest_Buffers::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyRequest_Buffers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyRequest_Buffers& NotifyRequest_Buffers::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

NotifyRequest_Buffers* NotifyRequest_Buffers::default_instance_ = NULL;

NotifyRequest_Buffers* NotifyRequest_Buffers::New() const {
  return new NotifyRequest_Buffers;
}

void NotifyRequest_Buffers::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    sva_ = GOOGLE_ULONGLONG(0);
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool NotifyRequest_Buffers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.NotifyRequest.Buffers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 sva = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sva_)));
          set_has_sva();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // required bytes data = 2;
      case 2: {
        if (tag == 18) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.NotifyRequest.Buffers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.NotifyRequest.Buffers)
  return false;
#undef DO_
}

void NotifyRequest_Buffers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.NotifyRequest.Buffers)
  // required uint64 sva = 1;
  if (has_sva()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sva(), output);
  }

  // required bytes data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.NotifyRequest.Buffers)
}

int NotifyRequest_Buffers::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 sva = 1;
    if (has_sva()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sva());
    }

    // required bytes data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyRequest_Buffers::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyRequest_Buffers*>(&from));
}

void NotifyRequest_Buffers::MergeFrom(const NotifyRequest_Buffers& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sva()) {
      set_sva(from.sva());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void NotifyRequest_Buffers::CopyFrom(const NotifyRequest_Buffers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyRequest_Buffers::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void NotifyRequest_Buffers::Swap(NotifyRequest_Buffers* other) {
  if (other != this) {
    std::swap(sva_, other->sva_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyRequest_Buffers::GetTypeName() const {
  return "com.trustonic.tee_proxy.NotifyRequest.Buffers";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int NotifyRequest::kSidFieldNumber;
const int NotifyRequest::kTciFieldNumber;
const int NotifyRequest::kBuffersFieldNumber;
#endif  // !_MSC_VER

NotifyRequest::NotifyRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.NotifyRequest)
}

void NotifyRequest::InitAsDefaultInstance() {
}

NotifyRequest::NotifyRequest(const NotifyRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.NotifyRequest)
}

void NotifyRequest::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  sid_ = 0u;
  tci_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyRequest::~NotifyRequest() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.NotifyRequest)
  SharedDtor();
}

void NotifyRequest::SharedDtor() {
  if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tci_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyRequest& NotifyRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

NotifyRequest* NotifyRequest::default_instance_ = NULL;

NotifyRequest* NotifyRequest::New() const {
  return new NotifyRequest;
}

void NotifyRequest::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    sid_ = 0u;
    if (has_tci()) {
      if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        tci_->clear();
      }
    }
  }
  buffers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool NotifyRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.NotifyRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sid_)));
          set_has_sid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_tci;
        break;
      }

      // optional bytes tci = 2;
      case 2: {
        if (tag == 18) {
         parse_tci:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_tci()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_buffers;
        break;
      }

      // repeated .com.trustonic.tee_proxy.NotifyRequest.Buffers buffers = 3;
      case 3: {
        if (tag == 26) {
         parse_buffers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_buffers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_buffers;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.NotifyRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.NotifyRequest)
  return false;
#undef DO_
}

void NotifyRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.NotifyRequest)
  // required uint32 sid = 1;
  if (has_sid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sid(), output);
  }

  // optional bytes tci = 2;
  if (has_tci()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->tci(), output);
  }

  // repeated .com.trustonic.tee_proxy.NotifyRequest.Buffers buffers = 3;
  for (int i = 0; i < this->buffers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->buffers(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.NotifyRequest)
}

int NotifyRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sid = 1;
    if (has_sid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sid());
    }

    // optional bytes tci = 2;
    if (has_tci()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->tci());
    }

  }
  // repeated .com.trustonic.tee_proxy.NotifyRequest.Buffers buffers = 3;
  total_size += 1 * this->buffers_size();
  for (int i = 0; i < this->buffers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->buffers(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyRequest*>(&from));
}

void NotifyRequest::MergeFrom(const NotifyRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  buffers_.MergeFrom(from.buffers_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sid()) {
      set_sid(from.sid());
    }
    if (from.has_tci()) {
      set_tci(from.tci());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void NotifyRequest::CopyFrom(const NotifyRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->buffers())) return false;
  return true;
}

void NotifyRequest::Swap(NotifyRequest* other) {
  if (other != this) {
    std::swap(sid_, other->sid_);
    std::swap(tci_, other->tci_);
    buffers_.Swap(&other->buffers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyRequest::GetTypeName() const {
  return "com.trustonic.tee_proxy.NotifyRequest";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

NotifyResponse::NotifyResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.NotifyResponse)
}

void NotifyResponse::InitAsDefaultInstance() {
}

NotifyResponse::NotifyResponse(const NotifyResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.NotifyResponse)
}

void NotifyResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NotifyResponse::~NotifyResponse() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.NotifyResponse)
  SharedDtor();
}

void NotifyResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void NotifyResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const NotifyResponse& NotifyResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

NotifyResponse* NotifyResponse::default_instance_ = NULL;

NotifyResponse* NotifyResponse::New() const {
  return new NotifyResponse;
}

void NotifyResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool NotifyResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.NotifyResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.NotifyResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.NotifyResponse)
  return false;
#undef DO_
}

void NotifyResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.NotifyResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.NotifyResponse)
}

int NotifyResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NotifyResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const NotifyResponse*>(&from));
}

void NotifyResponse::MergeFrom(const NotifyResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void NotifyResponse::CopyFrom(const NotifyResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NotifyResponse::IsInitialized() const {

  return true;
}

void NotifyResponse::Swap(NotifyResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string NotifyResponse::GetTypeName() const {
  return "com.trustonic.tee_proxy.NotifyResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int WaitNotificationRequest::kSidFieldNumber;
const int WaitNotificationRequest::kTimeoutFieldNumber;
const int WaitNotificationRequest::kPartialFieldNumber;
#endif  // !_MSC_VER

WaitNotificationRequest::WaitNotificationRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.WaitNotificationRequest)
}

void WaitNotificationRequest::InitAsDefaultInstance() {
}

WaitNotificationRequest::WaitNotificationRequest(const WaitNotificationRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.WaitNotificationRequest)
}

void WaitNotificationRequest::SharedCtor() {
  _cached_size_ = 0;
  sid_ = 0u;
  timeout_ = 0;
  partial_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WaitNotificationRequest::~WaitNotificationRequest() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.WaitNotificationRequest)
  SharedDtor();
}

void WaitNotificationRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void WaitNotificationRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const WaitNotificationRequest& WaitNotificationRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

WaitNotificationRequest* WaitNotificationRequest::default_instance_ = NULL;

WaitNotificationRequest* WaitNotificationRequest::New() const {
  return new WaitNotificationRequest;
}

void WaitNotificationRequest::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<WaitNotificationRequest*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(sid_, partial_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool WaitNotificationRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.WaitNotificationRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sid_)));
          set_has_sid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_timeout;
        break;
      }

      // required sint32 timeout = 2;
      case 2: {
        if (tag == 16) {
         parse_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &timeout_)));
          set_has_timeout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_partial;
        break;
      }

      // required bool partial = 3;
      case 3: {
        if (tag == 24) {
         parse_partial:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &partial_)));
          set_has_partial();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.WaitNotificationRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.WaitNotificationRequest)
  return false;
#undef DO_
}

void WaitNotificationRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.WaitNotificationRequest)
  // required uint32 sid = 1;
  if (has_sid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sid(), output);
  }

  // required sint32 timeout = 2;
  if (has_timeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->timeout(), output);
  }

  // required bool partial = 3;
  if (has_partial()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->partial(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.WaitNotificationRequest)
}

int WaitNotificationRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sid = 1;
    if (has_sid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sid());
    }

    // required sint32 timeout = 2;
    if (has_timeout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->timeout());
    }

    // required bool partial = 3;
    if (has_partial()) {
      total_size += 1 + 1;
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WaitNotificationRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const WaitNotificationRequest*>(&from));
}

void WaitNotificationRequest::MergeFrom(const WaitNotificationRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sid()) {
      set_sid(from.sid());
    }
    if (from.has_timeout()) {
      set_timeout(from.timeout());
    }
    if (from.has_partial()) {
      set_partial(from.partial());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void WaitNotificationRequest::CopyFrom(const WaitNotificationRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WaitNotificationRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void WaitNotificationRequest::Swap(WaitNotificationRequest* other) {
  if (other != this) {
    std::swap(sid_, other->sid_);
    std::swap(timeout_, other->timeout_);
    std::swap(partial_, other->partial_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string WaitNotificationRequest::GetTypeName() const {
  return "com.trustonic.tee_proxy.WaitNotificationRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int WaitNotificationResponse_Buffers::kSvaFieldNumber;
const int WaitNotificationResponse_Buffers::kDataFieldNumber;
#endif  // !_MSC_VER

WaitNotificationResponse_Buffers::WaitNotificationResponse_Buffers()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers)
}

void WaitNotificationResponse_Buffers::InitAsDefaultInstance() {
}

WaitNotificationResponse_Buffers::WaitNotificationResponse_Buffers(const WaitNotificationResponse_Buffers& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers)
}

void WaitNotificationResponse_Buffers::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  sva_ = GOOGLE_ULONGLONG(0);
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WaitNotificationResponse_Buffers::~WaitNotificationResponse_Buffers() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers)
  SharedDtor();
}

void WaitNotificationResponse_Buffers::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void WaitNotificationResponse_Buffers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const WaitNotificationResponse_Buffers& WaitNotificationResponse_Buffers::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

WaitNotificationResponse_Buffers* WaitNotificationResponse_Buffers::default_instance_ = NULL;

WaitNotificationResponse_Buffers* WaitNotificationResponse_Buffers::New() const {
  return new WaitNotificationResponse_Buffers;
}

void WaitNotificationResponse_Buffers::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    sva_ = GOOGLE_ULONGLONG(0);
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool WaitNotificationResponse_Buffers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 sva = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sva_)));
          set_has_sva();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // required bytes data = 2;
      case 2: {
        if (tag == 18) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers)
  return false;
#undef DO_
}

void WaitNotificationResponse_Buffers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers)
  // required uint64 sva = 1;
  if (has_sva()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sva(), output);
  }

  // required bytes data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->data(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.WaitNotificationResponse.Buffers)
}

int WaitNotificationResponse_Buffers::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 sva = 1;
    if (has_sva()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sva());
    }

    // required bytes data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WaitNotificationResponse_Buffers::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const WaitNotificationResponse_Buffers*>(&from));
}

void WaitNotificationResponse_Buffers::MergeFrom(const WaitNotificationResponse_Buffers& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sva()) {
      set_sva(from.sva());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void WaitNotificationResponse_Buffers::CopyFrom(const WaitNotificationResponse_Buffers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WaitNotificationResponse_Buffers::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void WaitNotificationResponse_Buffers::Swap(WaitNotificationResponse_Buffers* other) {
  if (other != this) {
    std::swap(sva_, other->sva_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string WaitNotificationResponse_Buffers::GetTypeName() const {
  return "com.trustonic.tee_proxy.WaitNotificationResponse.Buffers";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int WaitNotificationResponse::kTciFieldNumber;
const int WaitNotificationResponse::kBuffersFieldNumber;
#endif  // !_MSC_VER

WaitNotificationResponse::WaitNotificationResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.WaitNotificationResponse)
}

void WaitNotificationResponse::InitAsDefaultInstance() {
}

WaitNotificationResponse::WaitNotificationResponse(const WaitNotificationResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.WaitNotificationResponse)
}

void WaitNotificationResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  tci_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WaitNotificationResponse::~WaitNotificationResponse() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.WaitNotificationResponse)
  SharedDtor();
}

void WaitNotificationResponse::SharedDtor() {
  if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tci_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void WaitNotificationResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const WaitNotificationResponse& WaitNotificationResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

WaitNotificationResponse* WaitNotificationResponse::default_instance_ = NULL;

WaitNotificationResponse* WaitNotificationResponse::New() const {
  return new WaitNotificationResponse;
}

void WaitNotificationResponse::Clear() {
  if (has_tci()) {
    if (tci_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
      tci_->clear();
    }
  }
  buffers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool WaitNotificationResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.WaitNotificationResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes tci = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_tci()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_buffers;
        break;
      }

      // repeated .com.trustonic.tee_proxy.WaitNotificationResponse.Buffers buffers = 2;
      case 2: {
        if (tag == 18) {
         parse_buffers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_buffers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_buffers;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.WaitNotificationResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.WaitNotificationResponse)
  return false;
#undef DO_
}

void WaitNotificationResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.WaitNotificationResponse)
  // optional bytes tci = 1;
  if (has_tci()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->tci(), output);
  }

  // repeated .com.trustonic.tee_proxy.WaitNotificationResponse.Buffers buffers = 2;
  for (int i = 0; i < this->buffers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->buffers(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.WaitNotificationResponse)
}

int WaitNotificationResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bytes tci = 1;
    if (has_tci()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->tci());
    }

  }
  // repeated .com.trustonic.tee_proxy.WaitNotificationResponse.Buffers buffers = 2;
  total_size += 1 * this->buffers_size();
  for (int i = 0; i < this->buffers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->buffers(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WaitNotificationResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const WaitNotificationResponse*>(&from));
}

void WaitNotificationResponse::MergeFrom(const WaitNotificationResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  buffers_.MergeFrom(from.buffers_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_tci()) {
      set_tci(from.tci());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void WaitNotificationResponse::CopyFrom(const WaitNotificationResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WaitNotificationResponse::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->buffers())) return false;
  return true;
}

void WaitNotificationResponse::Swap(WaitNotificationResponse* other) {
  if (other != this) {
    std::swap(tci_, other->tci_);
    buffers_.Swap(&other->buffers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string WaitNotificationResponse::GetTypeName() const {
  return "com.trustonic.tee_proxy.WaitNotificationResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int MapRequest_Buffers::kLenFieldNumber;
const int MapRequest_Buffers::kFlagsFieldNumber;
#endif  // !_MSC_VER

MapRequest_Buffers::MapRequest_Buffers()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.MapRequest.Buffers)
}

void MapRequest_Buffers::InitAsDefaultInstance() {
}

MapRequest_Buffers::MapRequest_Buffers(const MapRequest_Buffers& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.MapRequest.Buffers)
}

void MapRequest_Buffers::SharedCtor() {
  _cached_size_ = 0;
  len_ = 0u;
  flags_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapRequest_Buffers::~MapRequest_Buffers() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.MapRequest.Buffers)
  SharedDtor();
}

void MapRequest_Buffers::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MapRequest_Buffers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MapRequest_Buffers& MapRequest_Buffers::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

MapRequest_Buffers* MapRequest_Buffers::default_instance_ = NULL;

MapRequest_Buffers* MapRequest_Buffers::New() const {
  return new MapRequest_Buffers;
}

void MapRequest_Buffers::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<MapRequest_Buffers*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(len_, flags_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MapRequest_Buffers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.MapRequest.Buffers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 len = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &len_)));
          set_has_len();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_flags;
        break;
      }

      // required uint32 flags = 2;
      case 2: {
        if (tag == 16) {
         parse_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &flags_)));
          set_has_flags();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.MapRequest.Buffers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.MapRequest.Buffers)
  return false;
#undef DO_
}

void MapRequest_Buffers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.MapRequest.Buffers)
  // required uint32 len = 1;
  if (has_len()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->len(), output);
  }

  // required uint32 flags = 2;
  if (has_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->flags(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.MapRequest.Buffers)
}

int MapRequest_Buffers::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 len = 1;
    if (has_len()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->len());
    }

    // required uint32 flags = 2;
    if (has_flags()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->flags());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapRequest_Buffers::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MapRequest_Buffers*>(&from));
}

void MapRequest_Buffers::MergeFrom(const MapRequest_Buffers& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_len()) {
      set_len(from.len());
    }
    if (from.has_flags()) {
      set_flags(from.flags());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MapRequest_Buffers::CopyFrom(const MapRequest_Buffers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapRequest_Buffers::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void MapRequest_Buffers::Swap(MapRequest_Buffers* other) {
  if (other != this) {
    std::swap(len_, other->len_);
    std::swap(flags_, other->flags_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MapRequest_Buffers::GetTypeName() const {
  return "com.trustonic.tee_proxy.MapRequest.Buffers";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int MapRequest::kSidFieldNumber;
const int MapRequest::kBuffersFieldNumber;
#endif  // !_MSC_VER

MapRequest::MapRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.MapRequest)
}

void MapRequest::InitAsDefaultInstance() {
}

MapRequest::MapRequest(const MapRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.MapRequest)
}

void MapRequest::SharedCtor() {
  _cached_size_ = 0;
  sid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapRequest::~MapRequest() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.MapRequest)
  SharedDtor();
}

void MapRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MapRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MapRequest& MapRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

MapRequest* MapRequest::default_instance_ = NULL;

MapRequest* MapRequest::New() const {
  return new MapRequest;
}

void MapRequest::Clear() {
  sid_ = 0u;
  buffers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MapRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.MapRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sid_)));
          set_has_sid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_buffers;
        break;
      }

      // repeated .com.trustonic.tee_proxy.MapRequest.Buffers buffers = 2;
      case 2: {
        if (tag == 18) {
         parse_buffers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_buffers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_buffers;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.MapRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.MapRequest)
  return false;
#undef DO_
}

void MapRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.MapRequest)
  // required uint32 sid = 1;
  if (has_sid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sid(), output);
  }

  // repeated .com.trustonic.tee_proxy.MapRequest.Buffers buffers = 2;
  for (int i = 0; i < this->buffers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->buffers(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.MapRequest)
}

int MapRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sid = 1;
    if (has_sid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sid());
    }

  }
  // repeated .com.trustonic.tee_proxy.MapRequest.Buffers buffers = 2;
  total_size += 1 * this->buffers_size();
  for (int i = 0; i < this->buffers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->buffers(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MapRequest*>(&from));
}

void MapRequest::MergeFrom(const MapRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  buffers_.MergeFrom(from.buffers_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sid()) {
      set_sid(from.sid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MapRequest::CopyFrom(const MapRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->buffers())) return false;
  return true;
}

void MapRequest::Swap(MapRequest* other) {
  if (other != this) {
    std::swap(sid_, other->sid_);
    buffers_.Swap(&other->buffers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MapRequest::GetTypeName() const {
  return "com.trustonic.tee_proxy.MapRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int MapResponse_Buffers::kSvaFieldNumber;
#endif  // !_MSC_VER

MapResponse_Buffers::MapResponse_Buffers()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.MapResponse.Buffers)
}

void MapResponse_Buffers::InitAsDefaultInstance() {
}

MapResponse_Buffers::MapResponse_Buffers(const MapResponse_Buffers& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.MapResponse.Buffers)
}

void MapResponse_Buffers::SharedCtor() {
  _cached_size_ = 0;
  sva_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapResponse_Buffers::~MapResponse_Buffers() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.MapResponse.Buffers)
  SharedDtor();
}

void MapResponse_Buffers::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MapResponse_Buffers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MapResponse_Buffers& MapResponse_Buffers::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

MapResponse_Buffers* MapResponse_Buffers::default_instance_ = NULL;

MapResponse_Buffers* MapResponse_Buffers::New() const {
  return new MapResponse_Buffers;
}

void MapResponse_Buffers::Clear() {
  sva_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MapResponse_Buffers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.MapResponse.Buffers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 sva = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sva_)));
          set_has_sva();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.MapResponse.Buffers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.MapResponse.Buffers)
  return false;
#undef DO_
}

void MapResponse_Buffers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.MapResponse.Buffers)
  // required uint64 sva = 1;
  if (has_sva()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sva(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.MapResponse.Buffers)
}

int MapResponse_Buffers::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 sva = 1;
    if (has_sva()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sva());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapResponse_Buffers::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MapResponse_Buffers*>(&from));
}

void MapResponse_Buffers::MergeFrom(const MapResponse_Buffers& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sva()) {
      set_sva(from.sva());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MapResponse_Buffers::CopyFrom(const MapResponse_Buffers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapResponse_Buffers::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void MapResponse_Buffers::Swap(MapResponse_Buffers* other) {
  if (other != this) {
    std::swap(sva_, other->sva_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MapResponse_Buffers::GetTypeName() const {
  return "com.trustonic.tee_proxy.MapResponse.Buffers";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int MapResponse::kBuffersFieldNumber;
#endif  // !_MSC_VER

MapResponse::MapResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.MapResponse)
}

void MapResponse::InitAsDefaultInstance() {
}

MapResponse::MapResponse(const MapResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.MapResponse)
}

void MapResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapResponse::~MapResponse() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.MapResponse)
  SharedDtor();
}

void MapResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void MapResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const MapResponse& MapResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

MapResponse* MapResponse::default_instance_ = NULL;

MapResponse* MapResponse::New() const {
  return new MapResponse;
}

void MapResponse::Clear() {
  buffers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool MapResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.MapResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .com.trustonic.tee_proxy.MapResponse.Buffers buffers = 1;
      case 1: {
        if (tag == 10) {
         parse_buffers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_buffers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_buffers;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.MapResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.MapResponse)
  return false;
#undef DO_
}

void MapResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.MapResponse)
  // repeated .com.trustonic.tee_proxy.MapResponse.Buffers buffers = 1;
  for (int i = 0; i < this->buffers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->buffers(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.MapResponse)
}

int MapResponse::ByteSize() const {
  int total_size = 0;

  // repeated .com.trustonic.tee_proxy.MapResponse.Buffers buffers = 1;
  total_size += 1 * this->buffers_size();
  for (int i = 0; i < this->buffers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->buffers(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const MapResponse*>(&from));
}

void MapResponse::MergeFrom(const MapResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  buffers_.MergeFrom(from.buffers_);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void MapResponse::CopyFrom(const MapResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapResponse::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->buffers())) return false;
  return true;
}

void MapResponse::Swap(MapResponse* other) {
  if (other != this) {
    buffers_.Swap(&other->buffers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string MapResponse::GetTypeName() const {
  return "com.trustonic.tee_proxy.MapResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int UnmapRequest_Buffers::kSvaFieldNumber;
#endif  // !_MSC_VER

UnmapRequest_Buffers::UnmapRequest_Buffers()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.UnmapRequest.Buffers)
}

void UnmapRequest_Buffers::InitAsDefaultInstance() {
}

UnmapRequest_Buffers::UnmapRequest_Buffers(const UnmapRequest_Buffers& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.UnmapRequest.Buffers)
}

void UnmapRequest_Buffers::SharedCtor() {
  _cached_size_ = 0;
  sva_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnmapRequest_Buffers::~UnmapRequest_Buffers() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.UnmapRequest.Buffers)
  SharedDtor();
}

void UnmapRequest_Buffers::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UnmapRequest_Buffers::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UnmapRequest_Buffers& UnmapRequest_Buffers::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

UnmapRequest_Buffers* UnmapRequest_Buffers::default_instance_ = NULL;

UnmapRequest_Buffers* UnmapRequest_Buffers::New() const {
  return new UnmapRequest_Buffers;
}

void UnmapRequest_Buffers::Clear() {
  sva_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UnmapRequest_Buffers::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.UnmapRequest.Buffers)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 sva = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &sva_)));
          set_has_sva();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.UnmapRequest.Buffers)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.UnmapRequest.Buffers)
  return false;
#undef DO_
}

void UnmapRequest_Buffers::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.UnmapRequest.Buffers)
  // required uint64 sva = 1;
  if (has_sva()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->sva(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.UnmapRequest.Buffers)
}

int UnmapRequest_Buffers::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint64 sva = 1;
    if (has_sva()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->sva());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnmapRequest_Buffers::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UnmapRequest_Buffers*>(&from));
}

void UnmapRequest_Buffers::MergeFrom(const UnmapRequest_Buffers& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sva()) {
      set_sva(from.sva());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UnmapRequest_Buffers::CopyFrom(const UnmapRequest_Buffers& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnmapRequest_Buffers::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void UnmapRequest_Buffers::Swap(UnmapRequest_Buffers* other) {
  if (other != this) {
    std::swap(sva_, other->sva_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UnmapRequest_Buffers::GetTypeName() const {
  return "com.trustonic.tee_proxy.UnmapRequest.Buffers";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int UnmapRequest::kSidFieldNumber;
const int UnmapRequest::kBuffersFieldNumber;
#endif  // !_MSC_VER

UnmapRequest::UnmapRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.UnmapRequest)
}

void UnmapRequest::InitAsDefaultInstance() {
}

UnmapRequest::UnmapRequest(const UnmapRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.UnmapRequest)
}

void UnmapRequest::SharedCtor() {
  _cached_size_ = 0;
  sid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnmapRequest::~UnmapRequest() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.UnmapRequest)
  SharedDtor();
}

void UnmapRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UnmapRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UnmapRequest& UnmapRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

UnmapRequest* UnmapRequest::default_instance_ = NULL;

UnmapRequest* UnmapRequest::New() const {
  return new UnmapRequest;
}

void UnmapRequest::Clear() {
  sid_ = 0u;
  buffers_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UnmapRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.UnmapRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sid_)));
          set_has_sid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_buffers;
        break;
      }

      // repeated .com.trustonic.tee_proxy.UnmapRequest.Buffers buffers = 2;
      case 2: {
        if (tag == 18) {
         parse_buffers:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_buffers()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_buffers;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.UnmapRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.UnmapRequest)
  return false;
#undef DO_
}

void UnmapRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.UnmapRequest)
  // required uint32 sid = 1;
  if (has_sid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sid(), output);
  }

  // repeated .com.trustonic.tee_proxy.UnmapRequest.Buffers buffers = 2;
  for (int i = 0; i < this->buffers_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->buffers(i), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.UnmapRequest)
}

int UnmapRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sid = 1;
    if (has_sid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sid());
    }

  }
  // repeated .com.trustonic.tee_proxy.UnmapRequest.Buffers buffers = 2;
  total_size += 1 * this->buffers_size();
  for (int i = 0; i < this->buffers_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->buffers(i));
  }

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnmapRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UnmapRequest*>(&from));
}

void UnmapRequest::MergeFrom(const UnmapRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  buffers_.MergeFrom(from.buffers_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sid()) {
      set_sid(from.sid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UnmapRequest::CopyFrom(const UnmapRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnmapRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->buffers())) return false;
  return true;
}

void UnmapRequest::Swap(UnmapRequest* other) {
  if (other != this) {
    std::swap(sid_, other->sid_);
    buffers_.Swap(&other->buffers_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UnmapRequest::GetTypeName() const {
  return "com.trustonic.tee_proxy.UnmapRequest";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

UnmapResponse::UnmapResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.UnmapResponse)
}

void UnmapResponse::InitAsDefaultInstance() {
}

UnmapResponse::UnmapResponse(const UnmapResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.UnmapResponse)
}

void UnmapResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UnmapResponse::~UnmapResponse() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.UnmapResponse)
  SharedDtor();
}

void UnmapResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void UnmapResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const UnmapResponse& UnmapResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

UnmapResponse* UnmapResponse::default_instance_ = NULL;

UnmapResponse* UnmapResponse::New() const {
  return new UnmapResponse;
}

void UnmapResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool UnmapResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.UnmapResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.UnmapResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.UnmapResponse)
  return false;
#undef DO_
}

void UnmapResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.UnmapResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.UnmapResponse)
}

int UnmapResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UnmapResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const UnmapResponse*>(&from));
}

void UnmapResponse::MergeFrom(const UnmapResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void UnmapResponse::CopyFrom(const UnmapResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UnmapResponse::IsInitialized() const {

  return true;
}

void UnmapResponse::Swap(UnmapResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string UnmapResponse::GetTypeName() const {
  return "com.trustonic.tee_proxy.UnmapResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int GetErrorRequest::kSidFieldNumber;
#endif  // !_MSC_VER

GetErrorRequest::GetErrorRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.GetErrorRequest)
}

void GetErrorRequest::InitAsDefaultInstance() {
}

GetErrorRequest::GetErrorRequest(const GetErrorRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.GetErrorRequest)
}

void GetErrorRequest::SharedCtor() {
  _cached_size_ = 0;
  sid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetErrorRequest::~GetErrorRequest() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.GetErrorRequest)
  SharedDtor();
}

void GetErrorRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetErrorRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetErrorRequest& GetErrorRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

GetErrorRequest* GetErrorRequest::default_instance_ = NULL;

GetErrorRequest* GetErrorRequest::New() const {
  return new GetErrorRequest;
}

void GetErrorRequest::Clear() {
  sid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetErrorRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.GetErrorRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sid_)));
          set_has_sid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.GetErrorRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.GetErrorRequest)
  return false;
#undef DO_
}

void GetErrorRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.GetErrorRequest)
  // required uint32 sid = 1;
  if (has_sid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.GetErrorRequest)
}

int GetErrorRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sid = 1;
    if (has_sid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetErrorRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetErrorRequest*>(&from));
}

void GetErrorRequest::MergeFrom(const GetErrorRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sid()) {
      set_sid(from.sid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetErrorRequest::CopyFrom(const GetErrorRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetErrorRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetErrorRequest::Swap(GetErrorRequest* other) {
  if (other != this) {
    std::swap(sid_, other->sid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetErrorRequest::GetTypeName() const {
  return "com.trustonic.tee_proxy.GetErrorRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int GetErrorResponse::kExitCodeFieldNumber;
#endif  // !_MSC_VER

GetErrorResponse::GetErrorResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.GetErrorResponse)
}

void GetErrorResponse::InitAsDefaultInstance() {
}

GetErrorResponse::GetErrorResponse(const GetErrorResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.GetErrorResponse)
}

void GetErrorResponse::SharedCtor() {
  _cached_size_ = 0;
  exit_code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetErrorResponse::~GetErrorResponse() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.GetErrorResponse)
  SharedDtor();
}

void GetErrorResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetErrorResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetErrorResponse& GetErrorResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

GetErrorResponse* GetErrorResponse::default_instance_ = NULL;

GetErrorResponse* GetErrorResponse::New() const {
  return new GetErrorResponse;
}

void GetErrorResponse::Clear() {
  exit_code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetErrorResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.GetErrorResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required sint32 exit_code = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &exit_code_)));
          set_has_exit_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.GetErrorResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.GetErrorResponse)
  return false;
#undef DO_
}

void GetErrorResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.GetErrorResponse)
  // required sint32 exit_code = 1;
  if (has_exit_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->exit_code(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.GetErrorResponse)
}

int GetErrorResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required sint32 exit_code = 1;
    if (has_exit_code()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->exit_code());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetErrorResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetErrorResponse*>(&from));
}

void GetErrorResponse::MergeFrom(const GetErrorResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_exit_code()) {
      set_exit_code(from.exit_code());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetErrorResponse::CopyFrom(const GetErrorResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetErrorResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GetErrorResponse::Swap(GetErrorResponse* other) {
  if (other != this) {
    std::swap(exit_code_, other->exit_code_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetErrorResponse::GetTypeName() const {
  return "com.trustonic.tee_proxy.GetErrorResponse";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GetVersionRequest::GetVersionRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.GetVersionRequest)
}

void GetVersionRequest::InitAsDefaultInstance() {
}

GetVersionRequest::GetVersionRequest(const GetVersionRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.GetVersionRequest)
}

void GetVersionRequest::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetVersionRequest::~GetVersionRequest() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.GetVersionRequest)
  SharedDtor();
}

void GetVersionRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetVersionRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetVersionRequest& GetVersionRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

GetVersionRequest* GetVersionRequest::default_instance_ = NULL;

GetVersionRequest* GetVersionRequest::New() const {
  return new GetVersionRequest;
}

void GetVersionRequest::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetVersionRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.GetVersionRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.GetVersionRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.GetVersionRequest)
  return false;
#undef DO_
}

void GetVersionRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.GetVersionRequest)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.GetVersionRequest)
}

int GetVersionRequest::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetVersionRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetVersionRequest*>(&from));
}

void GetVersionRequest::MergeFrom(const GetVersionRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetVersionRequest::CopyFrom(const GetVersionRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetVersionRequest::IsInitialized() const {

  return true;
}

void GetVersionRequest::Swap(GetVersionRequest* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetVersionRequest::GetTypeName() const {
  return "com.trustonic.tee_proxy.GetVersionRequest";
}


// ===================================================================

#ifndef _MSC_VER
const int GetVersionResponse::kProductIdFieldNumber;
const int GetVersionResponse::kMciFieldNumber;
const int GetVersionResponse::kSoFieldNumber;
const int GetVersionResponse::kMclfFieldNumber;
const int GetVersionResponse::kContainerFieldNumber;
const int GetVersionResponse::kMcConfigFieldNumber;
const int GetVersionResponse::kTlApiFieldNumber;
const int GetVersionResponse::kDrApiFieldNumber;
const int GetVersionResponse::kNwdFieldNumber;
#endif  // !_MSC_VER

GetVersionResponse::GetVersionResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.GetVersionResponse)
}

void GetVersionResponse::InitAsDefaultInstance() {
}

GetVersionResponse::GetVersionResponse(const GetVersionResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.GetVersionResponse)
}

void GetVersionResponse::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  product_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  mci_ = 0u;
  so_ = 0u;
  mclf_ = 0u;
  container_ = 0u;
  mc_config_ = 0u;
  tl_api_ = 0u;
  dr_api_ = 0u;
  nwd_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GetVersionResponse::~GetVersionResponse() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.GetVersionResponse)
  SharedDtor();
}

void GetVersionResponse::SharedDtor() {
  if (product_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete product_id_;
  }
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GetVersionResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GetVersionResponse& GetVersionResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

GetVersionResponse* GetVersionResponse::default_instance_ = NULL;

GetVersionResponse* GetVersionResponse::New() const {
  return new GetVersionResponse;
}

void GetVersionResponse::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GetVersionResponse*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(mci_, dr_api_);
    if (has_product_id()) {
      if (product_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        product_id_->clear();
      }
    }
  }
  nwd_ = 0u;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GetVersionResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.GetVersionResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string product_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_product_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_mci;
        break;
      }

      // required uint32 mci = 2;
      case 2: {
        if (tag == 16) {
         parse_mci:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mci_)));
          set_has_mci();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_so;
        break;
      }

      // required uint32 so = 3;
      case 3: {
        if (tag == 24) {
         parse_so:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &so_)));
          set_has_so();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_mclf;
        break;
      }

      // required uint32 mclf = 4;
      case 4: {
        if (tag == 32) {
         parse_mclf:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mclf_)));
          set_has_mclf();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_container;
        break;
      }

      // required uint32 container = 5;
      case 5: {
        if (tag == 40) {
         parse_container:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &container_)));
          set_has_container();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_mc_config;
        break;
      }

      // required uint32 mc_config = 6;
      case 6: {
        if (tag == 48) {
         parse_mc_config:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mc_config_)));
          set_has_mc_config();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_tl_api;
        break;
      }

      // required uint32 tl_api = 7;
      case 7: {
        if (tag == 56) {
         parse_tl_api:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &tl_api_)));
          set_has_tl_api();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_dr_api;
        break;
      }

      // required uint32 dr_api = 8;
      case 8: {
        if (tag == 64) {
         parse_dr_api:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dr_api_)));
          set_has_dr_api();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_nwd;
        break;
      }

      // required uint32 nwd = 9;
      case 9: {
        if (tag == 72) {
         parse_nwd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &nwd_)));
          set_has_nwd();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.GetVersionResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.GetVersionResponse)
  return false;
#undef DO_
}

void GetVersionResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.GetVersionResponse)
  // required string product_id = 1;
  if (has_product_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->product_id(), output);
  }

  // required uint32 mci = 2;
  if (has_mci()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->mci(), output);
  }

  // required uint32 so = 3;
  if (has_so()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->so(), output);
  }

  // required uint32 mclf = 4;
  if (has_mclf()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->mclf(), output);
  }

  // required uint32 container = 5;
  if (has_container()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->container(), output);
  }

  // required uint32 mc_config = 6;
  if (has_mc_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->mc_config(), output);
  }

  // required uint32 tl_api = 7;
  if (has_tl_api()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->tl_api(), output);
  }

  // required uint32 dr_api = 8;
  if (has_dr_api()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->dr_api(), output);
  }

  // required uint32 nwd = 9;
  if (has_nwd()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(9, this->nwd(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.GetVersionResponse)
}

int GetVersionResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string product_id = 1;
    if (has_product_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->product_id());
    }

    // required uint32 mci = 2;
    if (has_mci()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mci());
    }

    // required uint32 so = 3;
    if (has_so()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->so());
    }

    // required uint32 mclf = 4;
    if (has_mclf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mclf());
    }

    // required uint32 container = 5;
    if (has_container()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->container());
    }

    // required uint32 mc_config = 6;
    if (has_mc_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mc_config());
    }

    // required uint32 tl_api = 7;
    if (has_tl_api()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->tl_api());
    }

    // required uint32 dr_api = 8;
    if (has_dr_api()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->dr_api());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required uint32 nwd = 9;
    if (has_nwd()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->nwd());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GetVersionResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GetVersionResponse*>(&from));
}

void GetVersionResponse::MergeFrom(const GetVersionResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_product_id()) {
      set_product_id(from.product_id());
    }
    if (from.has_mci()) {
      set_mci(from.mci());
    }
    if (from.has_so()) {
      set_so(from.so());
    }
    if (from.has_mclf()) {
      set_mclf(from.mclf());
    }
    if (from.has_container()) {
      set_container(from.container());
    }
    if (from.has_mc_config()) {
      set_mc_config(from.mc_config());
    }
    if (from.has_tl_api()) {
      set_tl_api(from.tl_api());
    }
    if (from.has_dr_api()) {
      set_dr_api(from.dr_api());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_nwd()) {
      set_nwd(from.nwd());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GetVersionResponse::CopyFrom(const GetVersionResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetVersionResponse::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001ff) != 0x000001ff) return false;

  return true;
}

void GetVersionResponse::Swap(GetVersionResponse* other) {
  if (other != this) {
    std::swap(product_id_, other->product_id_);
    std::swap(mci_, other->mci_);
    std::swap(so_, other->so_);
    std::swap(mclf_, other->mclf_);
    std::swap(container_, other->container_);
    std::swap(mc_config_, other->mc_config_);
    std::swap(tl_api_, other->tl_api_);
    std::swap(dr_api_, other->dr_api_);
    std::swap(nwd_, other->nwd_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GetVersionResponse::GetTypeName() const {
  return "com.trustonic.tee_proxy.GetVersionResponse";
}


// ===================================================================

#ifndef _MSC_VER
const int GpRequestCancellationRequest::kSidFieldNumber;
#endif  // !_MSC_VER

GpRequestCancellationRequest::GpRequestCancellationRequest()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.GpRequestCancellationRequest)
}

void GpRequestCancellationRequest::InitAsDefaultInstance() {
}

GpRequestCancellationRequest::GpRequestCancellationRequest(const GpRequestCancellationRequest& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.GpRequestCancellationRequest)
}

void GpRequestCancellationRequest::SharedCtor() {
  _cached_size_ = 0;
  sid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GpRequestCancellationRequest::~GpRequestCancellationRequest() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.GpRequestCancellationRequest)
  SharedDtor();
}

void GpRequestCancellationRequest::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GpRequestCancellationRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GpRequestCancellationRequest& GpRequestCancellationRequest::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

GpRequestCancellationRequest* GpRequestCancellationRequest::default_instance_ = NULL;

GpRequestCancellationRequest* GpRequestCancellationRequest::New() const {
  return new GpRequestCancellationRequest;
}

void GpRequestCancellationRequest::Clear() {
  sid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GpRequestCancellationRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.GpRequestCancellationRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 sid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &sid_)));
          set_has_sid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(
            input, tag, &unknown_fields_stream));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.GpRequestCancellationRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.GpRequestCancellationRequest)
  return false;
#undef DO_
}

void GpRequestCancellationRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.GpRequestCancellationRequest)
  // required uint32 sid = 1;
  if (has_sid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->sid(), output);
  }

  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.GpRequestCancellationRequest)
}

int GpRequestCancellationRequest::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 sid = 1;
    if (has_sid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->sid());
    }

  }
  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GpRequestCancellationRequest::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GpRequestCancellationRequest*>(&from));
}

void GpRequestCancellationRequest::MergeFrom(const GpRequestCancellationRequest& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sid()) {
      set_sid(from.sid());
    }
  }
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GpRequestCancellationRequest::CopyFrom(const GpRequestCancellationRequest& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GpRequestCancellationRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void GpRequestCancellationRequest::Swap(GpRequestCancellationRequest* other) {
  if (other != this) {
    std::swap(sid_, other->sid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GpRequestCancellationRequest::GetTypeName() const {
  return "com.trustonic.tee_proxy.GpRequestCancellationRequest";
}


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

GpRequestCancellationResponse::GpRequestCancellationResponse()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:com.trustonic.tee_proxy.GpRequestCancellationResponse)
}

void GpRequestCancellationResponse::InitAsDefaultInstance() {
}

GpRequestCancellationResponse::GpRequestCancellationResponse(const GpRequestCancellationResponse& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:com.trustonic.tee_proxy.GpRequestCancellationResponse)
}

void GpRequestCancellationResponse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GpRequestCancellationResponse::~GpRequestCancellationResponse() {
  // @@protoc_insertion_point(destructor:com.trustonic.tee_proxy.GpRequestCancellationResponse)
  SharedDtor();
}

void GpRequestCancellationResponse::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void GpRequestCancellationResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const GpRequestCancellationResponse& GpRequestCancellationResponse::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_mc_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_mc_2eproto();
#endif
  return *default_instance_;
}

GpRequestCancellationResponse* GpRequestCancellationResponse::default_instance_ = NULL;

GpRequestCancellationResponse* GpRequestCancellationResponse::New() const {
  return new GpRequestCancellationResponse;
}

void GpRequestCancellationResponse::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->clear();
}

bool GpRequestCancellationResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  ::google::protobuf::io::StringOutputStream unknown_fields_string(
      mutable_unknown_fields());
  ::google::protobuf::io::CodedOutputStream unknown_fields_stream(
      &unknown_fields_string);
  // @@protoc_insertion_point(parse_start:com.trustonic.tee_proxy.GpRequestCancellationResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(
        input, tag, &unknown_fields_stream));
  }
success:
  // @@protoc_insertion_point(parse_success:com.trustonic.tee_proxy.GpRequestCancellationResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:com.trustonic.tee_proxy.GpRequestCancellationResponse)
  return false;
#undef DO_
}

void GpRequestCancellationResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:com.trustonic.tee_proxy.GpRequestCancellationResponse)
  output->WriteRaw(unknown_fields().data(),
                   unknown_fields().size());
  // @@protoc_insertion_point(serialize_end:com.trustonic.tee_proxy.GpRequestCancellationResponse)
}

int GpRequestCancellationResponse::ByteSize() const {
  int total_size = 0;

  total_size += unknown_fields().size();

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GpRequestCancellationResponse::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const GpRequestCancellationResponse*>(&from));
}

void GpRequestCancellationResponse::MergeFrom(const GpRequestCancellationResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  mutable_unknown_fields()->append(from.unknown_fields());
}

void GpRequestCancellationResponse::CopyFrom(const GpRequestCancellationResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GpRequestCancellationResponse::IsInitialized() const {

  return true;
}

void GpRequestCancellationResponse::Swap(GpRequestCancellationResponse* other) {
  if (other != this) {
    _unknown_fields_.swap(other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string GpRequestCancellationResponse::GetTypeName() const {
  return "com.trustonic.tee_proxy.GpRequestCancellationResponse";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace tee_proxy
}  // namespace trustonic
}  // namespace com

// @@protoc_insertion_point(global_scope)
